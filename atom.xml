<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>--小 · 崧 · 子--</title>
  
  <subtitle>小崧子的最爱吃小松子</subtitle>
  <link href="https://lennon.work/atom.xml" rel="self"/>
  
  <link href="https://lennon.work/"/>
  <updated>2023-11-03T08:39:38.127Z</updated>
  <id>https://lennon.work/</id>
  
  <author>
    <name>Lennon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>道德经</title>
    <link href="https://lennon.work/2023/11/03/%E8%AF%BB%E4%B9%A6/ddj/"/>
    <id>https://lennon.work/2023/11/03/%E8%AF%BB%E4%B9%A6/ddj/</id>
    <published>2023-11-03T08:32:11.577Z</published>
    <updated>2023-11-03T08:39:38.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><h6 id="道可道"><a href="#道可道" class="headerlink" title="道可道"></a>道可道</h6><p>道可道，非常道；名可名，非常名。无名，天地之始；有名，万物之母。故常无欲以观其妙，常有欲以观其徼。此两者同出而异名。同谓之玄，玄之又玄，众妙之门。</p><hr><h2 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h2><h6 id="天下皆知美之为美"><a href="#天下皆知美之为美" class="headerlink" title="天下皆知美之为美"></a>天下皆知美之为美</h6><p>天下皆知美之为美，斯恶已；皆知善之为善，斯不善已。故有无相生，难易相成，长短相形，高下相倾，音声相和，前后相随。是以圣人处无为之事，行不言之教，万物作焉而不辞。生而不有，为而不恃，功成而不居。夫唯弗居，是以不去。</p><hr><h2 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a>Chapter 3</h2><h6 id="为无为，则无不治"><a href="#为无为，则无不治" class="headerlink" title="为无为，则无不治"></a>为无为，则无不治</h6><p>不尚贤，使民不争；不贵难得之货，使民不为盗；不见可欲，使民心不乱。是以圣人之治，虚其心，实其腹，弱其志，强其骨；常使民无知无欲，使夫知者不敢为也。为无为，则无不治。</p><hr><h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><h6 id="道冲而用之"><a href="#道冲而用之" class="headerlink" title="道冲而用之"></a>道冲而用之</h6><p>道冲而用之，或不盈，渊乎似万物之宗。挫其锐，解其纷，和其光，同其尘。湛兮似若存。吾不知谁之子，象帝之先。</p><hr><h2 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h2><h6 id="天地不仁"><a href="#天地不仁" class="headerlink" title="天地不仁"></a>天地不仁</h6><p>天地不仁，以万物为刍狗；圣人不仁，以百姓为刍狗。天地之间，其犹橐籥乎？虚而不屈，动而愈出。多言数穷，不如守中。</p><hr><h2 id="Chapter-6"><a href="#Chapter-6" class="headerlink" title="Chapter 6"></a>Chapter 6</h2><h6 id="谷神不死，是谓玄牝"><a href="#谷神不死，是谓玄牝" class="headerlink" title="谷神不死，是谓玄牝"></a>谷神不死，是谓玄牝</h6><p>谷神不死，是谓玄牝。玄牝之门，是谓天地根。绵绵若存，用之不勤。</p><hr><h2 id="Chapter-7"><a href="#Chapter-7" class="headerlink" title="Chapter 7"></a>Chapter 7</h2><h6 id="天长地久"><a href="#天长地久" class="headerlink" title="天长地久"></a>天长地久</h6><p>天长地久。天地所以能长且久者，以其不自生，故能长生。是以圣人后其身，而身先；外其身，而身存。非以其无私者邪？故能成其私。</p><hr><h2 id="Chapter-8"><a href="#Chapter-8" class="headerlink" title="Chapter 8"></a>Chapter 8</h2><h6 id="上善若水"><a href="#上善若水" class="headerlink" title="上善若水"></a>上善若水</h6><p>上善若水。水利万物而不争，处众人之所恶，故几于道。居善地，心善渊，与善仁，言善信，正善治，事善能，动善时。夫唯不争，故无尤。</p><hr><h2 id="Chapter-9"><a href="#Chapter-9" class="headerlink" title="Chapter 9"></a>Chapter 9</h2><h6 id="功成名遂身退，天之道"><a href="#功成名遂身退，天之道" class="headerlink" title="功成名遂身退，天之道"></a>功成名遂身退，天之道</h6><p>持而盈之，不如其已；揣而锐之，不可常保。金玉满堂，莫之能守；富贵而骄，自遗其咎。功成名遂身退，天之道。</p><hr><h2 id="Chapter-10"><a href="#Chapter-10" class="headerlink" title="Chapter 10"></a>Chapter 10</h2><h6 id="载营魄，抱一，能无离乎"><a href="#载营魄，抱一，能无离乎" class="headerlink" title="载营魄，抱一，能无离乎"></a>载营魄，抱一，能无离乎</h6><p>载营魄，抱一，能无离乎？专气致柔，能婴儿乎？涤除玄览，能无疵乎？爱民治国，能无知乎？天门开阖，能无雌乎？明白四达，能无知乎？生之畜之，生而不有，为而不恃，长而不宰，是为玄德。</p><hr><h2 id="Chapter-11"><a href="#Chapter-11" class="headerlink" title="Chapter 11"></a>Chapter 11</h2><h6 id="无用"><a href="#无用" class="headerlink" title="无用"></a>无用</h6><p>三十辐，共一毂，当其无，有车之用。埏埴以为器，当其无，有器之用。凿户牖以为室，当其无，有室之用。故有之以为利，无之以为用。</p><hr><h2 id="Chapter-12"><a href="#Chapter-12" class="headerlink" title="Chapter 12"></a>Chapter 12</h2><h6 id="归元"><a href="#归元" class="headerlink" title="归元"></a>归元</h6><p>五色令人目盲，五音令人耳聋，五味令人口爽，驰骋田猎令人心发枉，难得之货令人行妨。是以圣人为腹不为目，故去彼取此。</p><hr><h2 id="Chapter-13"><a href="#Chapter-13" class="headerlink" title="Chapter 13"></a>Chapter 13</h2><h6 id="宠辱若惊"><a href="#宠辱若惊" class="headerlink" title="宠辱若惊"></a>宠辱若惊</h6><p>宠辱若惊，贵大患若身。何谓宠辱？辱为下，得之若惊，失之若惊，是谓宠辱若惊。何谓贵大患若身？吾所以有大患者，为吾有身。及吾无身，吾有何患？故贵以身为天下者，则可寄于天下。爱以身为天下者，乃可以托于天下。</p><hr><h2 id="Chapter-14"><a href="#Chapter-14" class="headerlink" title="Chapter 14"></a>Chapter 14</h2><h6 id="道纪"><a href="#道纪" class="headerlink" title="道纪"></a>道纪</h6><p>视之不见名曰夷，听之不闻名曰希，抟之不得名曰微。此三者不可致诘，故混而为一。其上不皦，其下不昧，绳绳不可名，复归于无物。是谓无状之状，无物之像，是谓惚恍。迎之不见其首，随之不见其后；执古之道，以御今之有。以知古始，是谓道纪。</p><hr><h2 id="Chapter-15"><a href="#Chapter-15" class="headerlink" title="Chapter 15"></a>Chapter 15</h2><h6 id="为士"><a href="#为士" class="headerlink" title="为士"></a>为士</h6><p>古之善为士者，微妙玄通，深不可识。夫唯不可识，故强为之容。与兮若冬涉川，犹兮若畏四邻，俨兮其若客，涣兮若冰之将释，敦兮其若朴，旷兮其若谷，浑兮其若浊。孰能浊以止？静之徐清。孰能安以久？动之徐生。保此道者不欲盈。夫唯不盈，故能蔽而不新成。</p><hr><h2 id="Chapter-16"><a href="#Chapter-16" class="headerlink" title="Chapter 16"></a>Chapter 16</h2><h6 id="观复"><a href="#观复" class="headerlink" title="观复"></a>观复</h6><p>至虚极，守静笃，万物并作，吾以观其复。夫物芸芸，各复归其根。归根曰静，静曰复命，复命曰常，知常曰明。不知常，妄作凶。知常容，容乃公，公乃王，王乃天，天乃道，道乃久，没身不殁。</p><hr><h2 id="Chapter-17"><a href="#Chapter-17" class="headerlink" title="Chapter 17"></a>Chapter 17</h2><h6 id="太上下之有之"><a href="#太上下之有之" class="headerlink" title="太上下之有之"></a>太上下之有之</h6><p>太上下之有之，其次亲之誉之，其次畏之，其次侮之，信不足焉，有不信焉，犹兮其贵言。功成事遂，百姓皆谓我自然。</p><hr><h2 id="Chapter-18"><a href="#Chapter-18" class="headerlink" title="Chapter 18"></a>Chapter 18</h2><h6 id="大道废"><a href="#大道废" class="headerlink" title="大道废"></a>大道废</h6><p>大道废，有仁义。智惠出，有大伪。六亲不和，有孝慈。国家昏乱，有忠臣。</p><hr><h2 id="Chapter-19"><a href="#Chapter-19" class="headerlink" title="Chapter 19"></a>Chapter 19</h2><h6 id="绝圣弃智"><a href="#绝圣弃智" class="headerlink" title="绝圣弃智"></a>绝圣弃智</h6><p>绝圣弃智，民利百倍。绝仁弃义，民复孝慈。绝巧弃利，盗贼无忧。此三者，以为文不足，故令有所属。见素抱朴，少私寡欲，绝学无忧。</p><hr><h2 id="Chapter-20"><a href="#Chapter-20" class="headerlink" title="Chapter 20"></a>Chapter 20</h2><h6 id="唯之与阿"><a href="#唯之与阿" class="headerlink" title="唯之与阿"></a>唯之与阿</h6><p>唯之与阿，相去几何？善之与恶，相去何若？人之所畏，不可不畏。荒兮其未央哉！众人熙熙，如享太牢，如春登台。我独怕兮其未兆，如婴儿之未孩，乘乘兮若无所归。众人皆有余，而我独若遗。我愚人之心也哉！沌沌兮。俗人昭昭，我独若昏；俗人察察，我独闷闷。忽兮若海，漂兮若无所止。众人皆有以，而我独顽似鄙。我独异于人，而贵食母。</p><hr><h2 id="Chapter-21"><a href="#Chapter-21" class="headerlink" title="Chapter 21"></a>Chapter 21</h2><h6 id="孔德之容"><a href="#孔德之容" class="headerlink" title="孔德之容"></a>孔德之容</h6><p>孔德之容，唯道是从。道之为物，唯恍唯忽。忽兮恍兮，其中有象；恍兮忽兮，其中有物。窈兮冥兮，其中有精。其精甚真，其中有信。自古及今，其名不去，以阅众甫。吾何以知众甫之然哉？以此。</p><hr><h2 id="Chapter-22"><a href="#Chapter-22" class="headerlink" title="Chapter 22"></a>Chapter 22</h2><h6 id="曲则全，枉则直"><a href="#曲则全，枉则直" class="headerlink" title="曲则全，枉则直"></a>曲则全，枉则直</h6><p>曲则全，枉则直，洼则盈，敝则新，少则得，多则惑。是以圣人抱一为天下式，不自见故明，不自视故彰，不自伐故有功，不自矜故长。夫唯不争，故天下莫能与之争。古之所谓曲则全者，岂虚言哉！诚全而归之。</p><hr><h2 id="Chapter-23"><a href="#Chapter-23" class="headerlink" title="Chapter 23"></a>Chapter 23</h2><h6 id="希言自然"><a href="#希言自然" class="headerlink" title="希言自然"></a>希言自然</h6><p>希言自然。飘风不终朝，骤雨不终日。孰为此者？天地。天地尚不能长久，而况于人乎？故从于道者，道者同于道，德者同于德，失者同于失。同于道者，道亦乐得之；同于德者，德亦乐得之；同于失者，失亦乐失之。信不足焉，有不信焉。</p><hr><h2 id="Chapter-24"><a href="#Chapter-24" class="headerlink" title="Chapter 24"></a>Chapter 24</h2><h6 id="跂者不立，跨者不行"><a href="#跂者不立，跨者不行" class="headerlink" title="跂者不立，跨者不行"></a>跂者不立，跨者不行</h6><p>跂者不立，跨者不行。自见者不明，自是者不彰，自伐者无功，自矜者不长。其于道也，曰余食赘行，物或恶之，故有道者不处也。</p><hr><h2 id="Chapter-25"><a href="#Chapter-25" class="headerlink" title="Chapter 25"></a>Chapter 25</h2><h6 id="有物混成，先天地生"><a href="#有物混成，先天地生" class="headerlink" title="有物混成，先天地生"></a>有物混成，先天地生</h6><p>有物混成，先天地生。寂兮廖兮，独立而不改，周行而不殆，可以为天下母。吾不知其名，字之曰道，强为名曰大。大曰逝，逝曰远，远曰反。故道大，天大，地大，王亦大。域中有四大，而王居其一焉。人法地，地法天，天法道，道法自然。</p><hr><h2 id="Chapter-26"><a href="#Chapter-26" class="headerlink" title="Chapter 26"></a>Chapter 26</h2><h6 id="重为轻根，静为躁君"><a href="#重为轻根，静为躁君" class="headerlink" title="重为轻根，静为躁君"></a>重为轻根，静为躁君</h6><p>重为轻根，静为躁君。是以圣人终日行，不离辎重。虽有荣观，燕处超然。奈何万乘之主，而以身轻天下？轻则失臣，躁则失君。</p><hr><h2 id="Chapter-27"><a href="#Chapter-27" class="headerlink" title="Chapter 27"></a>Chapter 27</h2><h6 id="善行无辙迹"><a href="#善行无辙迹" class="headerlink" title="善行无辙迹"></a>善行无辙迹</h6><p>善行无辙迹，善言无瑕谪，善计不用筹码，善闭无关楗而不可开，善结无绳约而不可解。是以圣人常善救人，故无弃人；常善救物，故无弃物，是谓袭明。故善人者，不善人之师；不善人者，善人之资。不贵其师，不爱其资，虽智大迷，是谓要妙。</p><hr><h2 id="Chapter-28"><a href="#Chapter-28" class="headerlink" title="Chapter 28"></a>Chapter 28</h2><h6 id="知其雄，守其雌"><a href="#知其雄，守其雌" class="headerlink" title="知其雄，守其雌"></a>知其雄，守其雌</h6><p>知其雄，守其雌，为天下谿；为天下谿，常德不离，复归于婴儿。知其白，守其黑，为天下式；为天下式，常德不忒，复归于无极。知其荣，守其辱，为天下谷；为天下谷，常德乃足，复归于朴。朴散则为器。圣人用之，则为官长，故大制不割。</p><hr><h2 id="Chapter-29"><a href="#Chapter-29" class="headerlink" title="Chapter 29"></a>Chapter 29</h2><h6 id="将欲取天下，而为之"><a href="#将欲取天下，而为之" class="headerlink" title="将欲取天下，而为之"></a>将欲取天下，而为之</h6><p>将欲取天下，而为之，吾见其不得已。天下神器不可为也。为者败之，执者失之。故物或行或随，或呴或吹，或强或羸，或载或隳。是以圣人去甚去奢去泰。</p><hr><h2 id="Chapter-30"><a href="#Chapter-30" class="headerlink" title="Chapter 30"></a>Chapter 30</h2><h6 id="以道佐人主者"><a href="#以道佐人主者" class="headerlink" title="以道佐人主者"></a>以道佐人主者</h6><p>以道佐人主者，不以兵强天下。其事好还。师之所处，荆棘生焉；大军之后，必有凶年。善者，果而已，不敢以强取。果而勿矜，果而勿伐，果而勿骄，果而不得已，果而勿强。物壮则老，是谓不道，不道早已。</p><hr><h2 id="Chapter-31"><a href="#Chapter-31" class="headerlink" title="Chapter 31"></a>Chapter 31</h2><h6 id="夫佳兵，不祥之器"><a href="#夫佳兵，不祥之器" class="headerlink" title="夫佳兵，不祥之器"></a>夫佳兵，不祥之器</h6><p>夫佳兵，不祥之器，物或恶之，故有道者不处。君子居则贵左，用兵则贵右。兵者，不祥之器，非君子之器，不得已而用之。恬淡为上，胜而不美。而美之者，是乐杀人。夫乐杀人者，则不可以得志于天下矣。吉事尚左，凶事尚右。偏将军居左，上将军居右，言以丧礼处之。杀人之众，以悲哀泣之。战胜以丧礼处之。</p><hr><h2 id="Chapter-32"><a href="#Chapter-32" class="headerlink" title="Chapter 32"></a>Chapter 32</h2><h6 id="道常无名"><a href="#道常无名" class="headerlink" title="道常无名"></a>道常无名</h6><p>道常无名，朴虽小，天下不敢臣。侯王若能守之，万物将自宾。天地相合，以降甘露。人莫之令而自均。始制有名，名亦既有，天亦将知之，知之所以不殆。譬道之在天下，犹川谷之与江海。</p><hr><h2 id="Chapter-33"><a href="#Chapter-33" class="headerlink" title="Chapter 33"></a>Chapter 33</h2><h6 id="知人者智，自知者明"><a href="#知人者智，自知者明" class="headerlink" title="知人者智，自知者明"></a>知人者智，自知者明</h6><p>知人者智，自知者明；胜人者有力，自胜者强。知足者富，强行者有志。不失其所者久，死而不亡者寿。</p><hr><h2 id="Chapter-34"><a href="#Chapter-34" class="headerlink" title="Chapter 34"></a>Chapter 34</h2><h6 id="大道汜兮"><a href="#大道汜兮" class="headerlink" title="大道汜兮"></a>大道汜兮</h6><p>大道汜兮，其可左右。万物恃之以生而不辞。功成而不有，爱养万物而不为主。常无欲，可名于小。万物归焉而不为主，可名为大。是以圣人终不为大，故能成其大。</p><hr><h2 id="Chapter-35"><a href="#Chapter-35" class="headerlink" title="Chapter 35"></a>Chapter 35</h2><h6 id="执大象，天下往"><a href="#执大象，天下往" class="headerlink" title="执大象，天下往"></a>执大象，天下往</h6><p>执大象，天下往。往而不害，安平太。乐与饵，过客止。道之出口，淡乎其无味。视之不足见，听之不足闻，用之不可既。</p><hr><h2 id="Chapter-36"><a href="#Chapter-36" class="headerlink" title="Chapter 36"></a>Chapter 36</h2><h6 id="将欲歙之，必固张之"><a href="#将欲歙之，必固张之" class="headerlink" title="将欲歙之，必固张之"></a>将欲歙之，必固张之</h6><p>将欲歙之，必固张之；将欲弱之，必固强之；将欲废之，必固兴之；将欲夺之，必固与之。是谓微明。柔弱胜刚强。鱼不可以脱于渊，国之利器不可以示人。</p><hr><h2 id="Chapter-37"><a href="#Chapter-37" class="headerlink" title="Chapter 37"></a>Chapter 37</h2><h6 id="道常无为而无不为"><a href="#道常无为而无不为" class="headerlink" title="道常无为而无不为"></a>道常无为而无不为</h6><p>道常无为而无不为。侯王若能守，万物将自化。化而欲作，吾将镇之以无名之朴。无名之朴，亦将不欲。不欲以静，天下将自定。</p><hr><h2 id="Chapter-38"><a href="#Chapter-38" class="headerlink" title="Chapter 38"></a>Chapter 38</h2><h6 id="上德不德，是以有德"><a href="#上德不德，是以有德" class="headerlink" title="上德不德，是以有德"></a>上德不德，是以有德</h6><p>上德不德，是以有德；下德不失德，是以无德。上德无为，而无以为；下德为之，而有以为。上仁为之，而无以为；上义为之，而有以为。上礼为之，而莫之应，则攘臂而仍之。故失道而后德，失德而后仁，失仁而后义，失义而后礼。夫礼者，忠信之薄，而乱之首；前识者，道之华，而愚之始。是以大丈夫处其厚，不居其薄；处其实，不居其华，故去彼取此。</p><hr><h2 id="Chapter-39"><a href="#Chapter-39" class="headerlink" title="Chapter 39"></a>Chapter 39</h2><h6 id="昔之得一者"><a href="#昔之得一者" class="headerlink" title="昔之得一者"></a>昔之得一者</h6><p>昔之得一者：天得一以清，地得一以宁；神得一以灵，谷得一以盈；万物得一以生，侯王得一以为天下正。其致之。天无以清，将恐裂；地无以宁，将恐发；神无以灵，将恐歇；谷无以盈，将恐歇；万物无以生，将恐灭；侯王无以贵高，将恐蹶。故贵必以贱为本，高必以下为基。是以侯王自谓孤、寡、不毂，此非以贱为本耶？非乎？故致数车无车，不欲瑑瑑如玉，落落如石。</p><hr><h2 id="Chapter-40"><a href="#Chapter-40" class="headerlink" title="Chapter 40"></a>Chapter 40</h2><h6 id="反者，道之动"><a href="#反者，道之动" class="headerlink" title="反者，道之动"></a>反者，道之动</h6><p>反者，道之动；弱者，道之用。天下万物生于有，有生于无。</p><hr><h2 id="Chapter-41"><a href="#Chapter-41" class="headerlink" title="Chapter 41"></a>Chapter 41</h2><h6 id="上士闻道"><a href="#上士闻道" class="headerlink" title="上士闻道"></a>上士闻道</h6><p>上士闻道，勤而行之；中士闻道，若存若亡；下士闻道，大笑之，不笑不足以为道。故建言有之：明道若昧，进道若退，夷道若类。上德若谷，大白若辱，广德若不足，建德若偷，质真若渝，大方无隅。大器晚成，大音希声，大象无形，道隐无名。夫唯道，善贷且成。</p><hr><h2 id="Chapter-42"><a href="#Chapter-42" class="headerlink" title="Chapter 42"></a>Chapter 42</h2><h6 id="道生一"><a href="#道生一" class="headerlink" title="道生一"></a>道生一</h6><p>道生一，一生二，二生三，三生万物。万物负阴抱阳，冲气以为和，人之所恶，为孤寡不毂，而王公以为称。故物或损之而益，或益之而损。人之所教，我亦教之，。强梁者不得其死。吾将以为教父。</p><hr><h2 id="Chapter-43"><a href="#Chapter-43" class="headerlink" title="Chapter 43"></a>Chapter 43</h2><h6 id="天下之至柔"><a href="#天下之至柔" class="headerlink" title="天下之至柔"></a>天下之至柔</h6><p>天下之至至柔，驰骋天下之至坚，无有入无间。吾是有之无为之有益。不言之教，无为之益，天下希及之。</p><hr><h2 id="Chapter-44"><a href="#Chapter-44" class="headerlink" title="Chapter 44"></a>Chapter 44</h2><h6 id="名与身孰亲？"><a href="#名与身孰亲？" class="headerlink" title="名与身孰亲？"></a>名与身孰亲？</h6><p>名与身孰亲？身与货孰多？得与亡孰病？甚爱必大废，多藏必厚亡。知足不辱，知止不殆，可以长久。</p><hr><h2 id="Chapter-45"><a href="#Chapter-45" class="headerlink" title="Chapter 45"></a>Chapter 45</h2><h6 id="大成若缺"><a href="#大成若缺" class="headerlink" title="大成若缺"></a>大成若缺</h6><p>大成若缺，其用不弊；大盈若冲，其用不穷。大直若屈，大巧若拙，大辩若讷。躁胜寒，静胜热，清静为天下正。</p><hr><h2 id="Chapter-46"><a href="#Chapter-46" class="headerlink" title="Chapter 46"></a>Chapter 46</h2><h6 id="走马以粪"><a href="#走马以粪" class="headerlink" title="走马以粪"></a>走马以粪</h6><p>天下有道，却走马以粪；天下无道，戎马生于郊。罪莫大于可欲，祸莫大于不知足，咎莫大于欲得。故知足之足，常足。</p><hr><h2 id="Chapter-47"><a href="#Chapter-47" class="headerlink" title="Chapter 47"></a>Chapter 47</h2><h6 id="不出户"><a href="#不出户" class="headerlink" title="不出户"></a>不出户</h6><p>不出户，知天下；不窥牑，见天道。其出弥远，其知弥少。是以圣人不行而知，不见而名，不为而成。</p><hr><h2 id="Chapter-48"><a href="#Chapter-48" class="headerlink" title="Chapter 48"></a>Chapter 48</h2><h6 id="为学日益"><a href="#为学日益" class="headerlink" title="为学日益"></a>为学日益</h6><p>为学日益，为道日损，损之又损，以至于无为，无为而无不为。取天下常以无事，及其有事，不足以取天下。</p><hr><h2 id="Chapter-49"><a href="#Chapter-49" class="headerlink" title="Chapter 49"></a>Chapter 49</h2><h6 id="圣人无常心"><a href="#圣人无常心" class="headerlink" title="圣人无常心"></a>圣人无常心</h6><p>圣人无常心，以百姓心为心。善者吾善之，不善者吾亦善之，德善；信者，吾信之，不信者，吾亦信之，德信。圣人在天下怵怵，为天下浑其心。百姓皆注其耳目，圣人皆孩之。</p><hr><h2 id="Chapter-50"><a href="#Chapter-50" class="headerlink" title="Chapter 50"></a>Chapter 50</h2><h6 id="出生入死"><a href="#出生入死" class="headerlink" title="出生入死"></a>出生入死</h6><p>出生入死。生之徒十有三，死之徒十有三。人之生，动之死地，十有三。夫何故？以其生生之厚。盖闻善摄生者，陆行不避兕虎，入军不避甲兵。兕无所投其角，虎无所措其爪，兵无所容其刃。夫何故？以其无死地。</p><h2 id="Chpater-51"><a href="#Chpater-51" class="headerlink" title="Chpater 51"></a>Chpater 51</h2><h6 id="道生之"><a href="#道生之" class="headerlink" title="道生之"></a>道生之</h6><p>道生之，德畜之，物形之，势成之。是以万物莫不尊道而贵德。道之尊，德之贵，夫莫之命而常自然。故道生之畜之，长之育之，成之熟之，养之覆之。生而不有，为而不恃，长而不宰，是谓玄德。</p><hr><h2 id="Chapter-52"><a href="#Chapter-52" class="headerlink" title="Chapter 52"></a>Chapter 52</h2><h6 id="天下有始"><a href="#天下有始" class="headerlink" title="天下有始"></a>天下有始</h6><p>天下有始，以为天下母。既知其母，复知其子；既知其子，复守其母，没身不殆。塞其兑，闭其门，终身不勤；开其兑，济其事，终身不救。见小曰明，守柔曰强。用其光，复归其明，无遗身殃，是谓习常。</p><hr><h2 id="Chapter-53"><a href="#Chapter-53" class="headerlink" title="Chapter 53"></a>Chapter 53</h2><h6 id="使我介然有知"><a href="#使我介然有知" class="headerlink" title="使我介然有知"></a>使我介然有知</h6><p>使我介然有之，行于大道。唯施是畏。大道甚夷，而民好径。朝甚除，田甚芜，仓甚虚。服文采，带利剑，厌饮食，财货有余。是谓盗夸，非道哉！</p><hr><h2 id="Chapter-54"><a href="#Chapter-54" class="headerlink" title="Chapter 54"></a>Chapter 54</h2><h6 id="善建者不拔，善抱者不脱"><a href="#善建者不拔，善抱者不脱" class="headerlink" title="善建者不拔，善抱者不脱"></a>善建者不拔，善抱者不脱</h6><p>善建者不拔，善抱者不脱，子孙祭祀不缀。修之于身，其德乃真；修之于家，其德乃余；修之于乡，其德乃长；修之于国，其德乃丰；修之于天下，其德乃普。故以身观身，以家观家，以乡观乡，以国观国，以天下观天下。吾何以知天下之然哉？以此。</p><hr><h2 id="Chapter-55"><a href="#Chapter-55" class="headerlink" title="Chapter 55"></a>Chapter 55</h2><h6 id="含德之厚，比于赤子"><a href="#含德之厚，比于赤子" class="headerlink" title="含德之厚，比于赤子"></a>含德之厚，比于赤子</h6><p>含德之厚，比于赤子。毒虫不螫，猛兽不据，攫鸟不搏。骨弱筋柔而握固，未知牝牡之之合而䘒作，精之至也；终日号而不嗄，和之至也。知和曰常，知常曰明，益生曰祥，心使气曰强。物壮则老，谓之不道，不道早已。</p><hr><h2 id="Chapter-56"><a href="#Chapter-56" class="headerlink" title="Chapter 56"></a>Chapter 56</h2><h6 id="知者不言"><a href="#知者不言" class="headerlink" title="知者不言"></a>知者不言</h6><p>知者不言，言者不知。塞其兑，闭其门；挫其锐，解其纷；和其光，同其尘。是谓玄同。故不可得而亲，亦不可得而疏；不可得而利，亦不可得而害；不可得而贵，亦不可得而贱。故为天下贵。</p><hr><h2 id="Chapter-57"><a href="#Chapter-57" class="headerlink" title="Chapter 57"></a>Chapter 57</h2><h6 id="以正治国，以奇用兵"><a href="#以正治国，以奇用兵" class="headerlink" title="以正治国，以奇用兵"></a>以正治国，以奇用兵</h6><p>以正治国，以奇用兵，以无事取天下。吾何以知其然哉？以此。天下多忌讳，而民弥贫；民多利器，国家滋昏；人多伎巧，奇物滋起；法物滋彰，盗贼多有。故圣人云：我无为，而民自化；我好静，而民自正；我无事，而民自富；我无欲，而民自朴。</p><hr><h2 id="Chapter-58"><a href="#Chapter-58" class="headerlink" title="Chapter 58"></a>Chapter 58</h2><h6 id="其政闷闷，其民醇醇"><a href="#其政闷闷，其民醇醇" class="headerlink" title="其政闷闷，其民醇醇"></a>其政闷闷，其民醇醇</h6><p>其政闷闷，其民醇醇；其政察察，其民缺缺。祸兮，福之所依；福兮，祸之所伏。孰知其极？其无正？正复为奇，善复为妖。民之迷，其日固久。是以圣人方而不割，廉而不害，直而不肆，光而不耀。</p><hr><h2 id="Chapter-59"><a href="#Chapter-59" class="headerlink" title="Chapter 59"></a>Chapter 59</h2><h6 id="治人事天"><a href="#治人事天" class="headerlink" title="治人事天"></a>治人事天</h6><p>治人事天，莫若啬。夫唯啬，是谓早服。早服是谓重积德。重积德，则无不克；无不克则莫知其极；莫知其极，可以有国；有国之母，可以长久。是谓深根固蒂，长生久视之道。</p><hr><h2 id="Chapter-60"><a href="#Chapter-60" class="headerlink" title="Chapter 60"></a>Chapter 60</h2><h6 id="治大国，若烹小鲜"><a href="#治大国，若烹小鲜" class="headerlink" title="治大国，若烹小鲜"></a>治大国，若烹小鲜</h6><p>治大国，若烹小鲜。以道莅天下，其鬼不神。非其鬼不神，其神不伤人。非其神不伤人，圣人亦不伤人。夫两不相伤，故德交归焉。</p><hr><h2 id="Chapter-61"><a href="#Chapter-61" class="headerlink" title="Chapter 61"></a>Chapter 61</h2><h6 id="大国者下流"><a href="#大国者下流" class="headerlink" title="大国者下流"></a>大国者下流</h6><p>大国者下流，天下之交，天下之牝。牝常以静胜牡，以静为下。则大国以下小国，则取小国；小国以下大国，则取大国。故或下以取，或下而取。大国不过欲兼畜人，小国不过欲入事人。夫两者各得其所欲，大者亦为下。</p><hr><h2 id="Chapter-62"><a href="#Chapter-62" class="headerlink" title="Chapter 62"></a>Chapter 62</h2><h6 id="道者，万物之奥"><a href="#道者，万物之奥" class="headerlink" title="道者，万物之奥"></a>道者，万物之奥</h6><p>道者，万物之奥，善人之宝，不善人之所保。美言可以市，尊行可以加人。人之不善，何弃之有？故立天子，置三公。虽有拱璧，以先驷马，不知坐进此道。古之所以贵此道者何？不日以求得，有罪以免邪？故为天下贵。</p><hr><h2 id="Chapter-63"><a href="#Chapter-63" class="headerlink" title="Chapter 63"></a>Chapter 63</h2><h6 id="为无为，事无事"><a href="#为无为，事无事" class="headerlink" title="为无为，事无事"></a>为无为，事无事</h6><p>为无为，事无事，味无味，大小多少。报怨以德，图难于其易，为大于其细。天下难事必作于易，天下大事必作于细。是以圣人终不为大，故能成其大。夫轻诺必寡信，多易必多难。是以圣人犹难之，故终无难。</p><hr><h2 id="Chapter-64"><a href="#Chapter-64" class="headerlink" title="Chapter 64"></a>Chapter 64</h2><h6 id="其安易持，其未兆易谋"><a href="#其安易持，其未兆易谋" class="headerlink" title="其安易持，其未兆易谋"></a>其安易持，其未兆易谋</h6><p>其安易持，其未兆易谋，其脆易破，其微易散。为之于未有，治之于未乱。合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。为者败之，执者失之。圣人无为，故无败；无执，故无失。民之从事，常于几成而败之。慎终如始，则无败事。是以圣人欲不欲，不贵难得之货；学不学，复众人之所过，以辅万物之自然，而不敢为。</p><hr><h2 id="Chapter-65"><a href="#Chapter-65" class="headerlink" title="Chapter 65"></a>Chapter 65</h2><h6 id="古之善为道者，非以明民"><a href="#古之善为道者，非以明民" class="headerlink" title="古之善为道者，非以明民"></a>古之善为道者，非以明民</h6><p>古之善为道者，非以明民，将以愚之。民之难治，以其智多。以智治国，国之贼；不以智治国，国之福。知此两者亦楷式。常知楷式，是谓玄德。玄德深矣，远矣，与物反矣，乃至于大顺。</p><hr><h2 id="Chapter-66"><a href="#Chapter-66" class="headerlink" title="Chapter 66"></a>Chapter 66</h2><h6 id="江海所以能为百谷王者"><a href="#江海所以能为百谷王者" class="headerlink" title="江海所以能为百谷王者"></a>江海所以能为百谷王者</h6><p>江海所以能为百谷王者，以善下之，故能为百谷王。是以圣人欲上民，必以言下之；欲先民，必以身后之。是以圣人处上而民不重，处前而民不害。是以天下乐推而不厌。以其不争，故天下莫能与之争。</p><hr><h2 id="Chapter-67"><a href="#Chapter-67" class="headerlink" title="Chapter 67"></a>Chapter 67</h2><h6 id="天下皆谓我大，似不肖"><a href="#天下皆谓我大，似不肖" class="headerlink" title="天下皆谓我大，似不肖"></a>天下皆谓我大，似不肖</h6><p>天下皆谓我大，似不肖。夫唯大，故似不肖。若肖，久矣必细。夫我有三宝，持而宝之。一曰慈，二曰俭，三曰不敢为天下先。慈故能勇，俭故能广，不敢为天下先，故能成器长。今舍慈且勇，舍俭且广，舍后且先，死矣。夫慈，以战则胜，以守则固，天将救之，以慈卫之。</p><hr><h2 id="Chapter-68"><a href="#Chapter-68" class="headerlink" title="Chapter 68"></a>Chapter 68</h2><h6 id="善为士者不武"><a href="#善为士者不武" class="headerlink" title="善为士者不武"></a>善为士者不武</h6><p>善为士者不武，善战者不怒，善胜敌者不与，而敌自服也，善用人者为下。是谓不争之德，是谓用人之力，是谓配天，古之极。</p><hr><h2 id="Chapter-69"><a href="#Chapter-69" class="headerlink" title="Chapter 69"></a>Chapter 69</h2><h6 id="用兵有言"><a href="#用兵有言" class="headerlink" title="用兵有言"></a>用兵有言</h6><p>用兵有言：吾不敢为主而为客，不敢进寸而退尺。是谓行无行，攘无臂，仍无敌，执无兵。祸莫大于轻敌，轻敌几丧吾宝。故抗兵相加，哀者胜矣。</p><hr><h2 id="Chapter-70"><a href="#Chapter-70" class="headerlink" title="Chapter 70"></a>Chapter 70</h2><h6 id="吾言甚易知，甚易行"><a href="#吾言甚易知，甚易行" class="headerlink" title="吾言甚易知，甚易行"></a>吾言甚易知，甚易行</h6><p>吾言甚易知，甚易行。天下莫能知，莫能行。言有宗，事有君。夫唯无知，是以不我知。知我者希，则我者贵。是以圣人被褐怀玉。</p><hr><h2 id="Chapter-71"><a href="#Chapter-71" class="headerlink" title="Chapter 71"></a>Chapter 71</h2><h6 id="知不知，上"><a href="#知不知，上" class="headerlink" title="知不知，上"></a>知不知，上</h6><p>知不知，上；不知知，病。夫唯病病，是以不病。圣人不病，以其病病，是以不病。</p><hr><h2 id="Chapter-72"><a href="#Chapter-72" class="headerlink" title="Chapter 72"></a>Chapter 72</h2><h6 id="民不畏威，大威至矣"><a href="#民不畏威，大威至矣" class="headerlink" title="民不畏威，大威至矣"></a>民不畏威，大威至矣</h6><p>民不畏威，大威至矣。无狭其所居，无厌其所生。夫唯不厌，是以不厌。是以圣人自知不自见，自爱不自贵，故取彼取此。</p><hr><h2 id="Chapter-73"><a href="#Chapter-73" class="headerlink" title="Chapter 73"></a>Chapter 73</h2><h6 id="勇于敢则杀，勇于不敢则活"><a href="#勇于敢则杀，勇于不敢则活" class="headerlink" title="勇于敢则杀，勇于不敢则活"></a>勇于敢则杀，勇于不敢则活</h6><p>勇于敢则杀，勇于不敢则活。此两者，或利或害。天之所恶，孰知其故？是以圣人犹难之。天之道不争而善胜，不言而善应，不召而自来， 繟然而善谋。天网恢恢，疏而不失。</p><hr><h2 id="Chapter-74"><a href="#Chapter-74" class="headerlink" title="Chapter 74"></a>Chapter 74</h2><h6 id="民不畏死"><a href="#民不畏死" class="headerlink" title="民不畏死"></a>民不畏死</h6><p>民不畏死，奈何以死惧之？若使民常畏死，而为奇者，吾得执而杀之，孰敢？常有司杀者。夫代司杀者，是谓代大匠斫。夫代大匠斫者，希有不伤其手矣。</p><hr><h2 id="Chapter-75"><a href="#Chapter-75" class="headerlink" title="Chapter 75"></a>Chapter 75</h2><h6 id="民之饥"><a href="#民之饥" class="headerlink" title="民之饥"></a>民之饥</h6><p>民之饥，以其上食税之多，是以饥；民之难治，以其上之有为，是以难治；民之轻死，以其求生之厚，是以轻死。夫唯无以生为者，是贤于贵生。</p><hr><h2 id="Chapter-76"><a href="#Chapter-76" class="headerlink" title="Chapter 76"></a>Chapter 76</h2><h6 id="人之生也柔弱"><a href="#人之生也柔弱" class="headerlink" title="人之生也柔弱"></a>人之生也柔弱</h6><p>人之生也柔弱，死也坚强。万物草木之生也柔脆，其死也枯槁。故坚强者死之徒，柔弱者生之徒。是以兵强则不胜，木强则共。强大处下，柔弱处上。</p><hr><h2 id="Chapter-77"><a href="#Chapter-77" class="headerlink" title="Chapter 77"></a>Chapter 77</h2><h6 id="天之道其犹张弓乎？"><a href="#天之道其犹张弓乎？" class="headerlink" title="天之道其犹张弓乎？"></a>天之道其犹张弓乎？</h6><p>天之道其犹张弓乎？高者抑之，下者举之；有余者损之，不足者与之。天之道，损有余而补不足，人之道则不然，损不足以奉有余。孰能有余以奉天下？唯有道者。是以圣人为而不恃，功成而不处，其不欲见贤。</p><hr><h2 id="Chapter-78"><a href="#Chapter-78" class="headerlink" title="Chapter 78"></a>Chapter 78</h2><h6 id="天下柔弱，莫过于水"><a href="#天下柔弱，莫过于水" class="headerlink" title="天下柔弱，莫过于水"></a>天下柔弱，莫过于水</h6><p>天下柔弱，莫过于水，而攻坚强者，莫知能胜。其无以易之。弱之胜强，柔之胜刚，天下莫不知，莫能行。故圣人云：受国之垢，是谓社稷主；受国之不详，是谓天下王。正言若反。</p><hr><h2 id="Chapter-79"><a href="#Chapter-79" class="headerlink" title="Chapter 79"></a>Chapter 79</h2><h6 id="和大怨，必有余怨"><a href="#和大怨，必有余怨" class="headerlink" title="和大怨，必有余怨"></a>和大怨，必有余怨</h6><p>和大怨，必有余怨。安可以为善？是以圣人执左契而不则于人。故有德司契，无徳司彻。天道无亲，常与善人。</p><hr><h2 id="Chapter-80"><a href="#Chapter-80" class="headerlink" title="Chapter 80"></a>Chapter 80</h2><h6 id="小国寡民"><a href="#小国寡民" class="headerlink" title="小国寡民"></a>小国寡民</h6><p>小国寡民，使有什伯人之器而不用，使民重死而不远徙。虽有舟舆，无所乘之；虽有甲兵，无所陈之；使人复结绳而用之。甘其食，美其服，安其居，乐其俗。邻国相望，鸡狗之声相闻，民至老死不相往来。</p><hr><h2 id="Chapter-81"><a href="#Chapter-81" class="headerlink" title="Chapter 81"></a>Chapter 81</h2><h6 id="信言不美，美言不信"><a href="#信言不美，美言不信" class="headerlink" title="信言不美，美言不信"></a>信言不美，美言不信</h6><p>信言不美，美言不信；善者不辩，辩者不善；知者不博，博者不知。圣人不积，既以为人，己愈有；既以与人，己愈多。天之道，利而不害；圣人之道，为而不争。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Chapter-1&quot;&gt;&lt;a href=&quot;#Chapter-1&quot; class=&quot;headerlink&quot; title=&quot;Chapter 1&quot;&gt;&lt;/a&gt;Chapter 1&lt;/h2&gt;&lt;h6 id=&quot;道可道&quot;&gt;&lt;a href=&quot;#道可道&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="背书" scheme="https://lennon.work/categories/%E8%83%8C%E4%B9%A6/"/>
    
    
    <category term="地狱难度" scheme="https://lennon.work/tags/%E5%9C%B0%E7%8B%B1%E9%9A%BE%E5%BA%A6/"/>
    
    <category term="年前背完" scheme="https://lennon.work/tags/%E5%B9%B4%E5%89%8D%E8%83%8C%E5%AE%8C/"/>
    
    <category term="极其重要" scheme="https://lennon.work/tags/%E6%9E%81%E5%85%B6%E9%87%8D%E8%A6%81/"/>
    
  </entry>
  
  <entry>
    <title>linux docker打包应用服务程序</title>
    <link href="https://lennon.work/2023/04/17/docker/docker%E6%89%93%E5%8C%85%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>https://lennon.work/2023/04/17/docker/docker%E6%89%93%E5%8C%85%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</id>
    <published>2023-04-17T02:11:42.551Z</published>
    <updated>2023-04-17T02:14:16.714Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、HTTP服务部署到Docker容器中创建一个Dockerfile"><a href="#一、HTTP服务部署到Docker容器中创建一个Dockerfile" class="headerlink" title="一、HTTP服务部署到Docker容器中创建一个Dockerfile"></a><strong>一、HTTP服务部署到Docker容器中创建一个Dockerfile</strong></h3><ol><li>选择基础镜像：选择一个适合您的应用程序的基础镜像，例如 Ubuntu 或 Alpine Linux，您可以在 Docker Hub 中找到许多可用的镜像。</li><li>安装必要的软件：安装 C++ 编译器和所需的库，例如 boost 和 OpenSSL。</li><li>将应用程序复制到容器中：将编译好的二进制文件或源代码复制到容器中。</li><li>暴露端口：使用 EXPOSE 命令将容器内的 HTTP 服务端口（例如 10522）暴露给外部。</li><li>设置启动命令：使用 CMD 命令设置容器启动时要运行的命令，例如启动您的 HTTP 服务。</li></ol><p>下面是一个简单的Dockerfile示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:latest</span><br><span class="line"></span><br><span class="line"># 安装必要的软件</span><br><span class="line">RUN apt-get update &amp;&amp; \</span><br><span class="line">    apt-get install -y g++ \</span><br><span class="line">                       libboost-all-dev \</span><br><span class="line">                       openssl \</span><br><span class="line">                       libssl-dev</span><br><span class="line"></span><br><span class="line"># 创建一个工作目录并复制应用程序</span><br><span class="line">WORKDIR &#x2F;app</span><br><span class="line">COPY my-http-server &#x2F;app</span><br><span class="line"></span><br><span class="line"># 暴露端口</span><br><span class="line">EXPOSE 10522</span><br><span class="line"></span><br><span class="line"># 设置启动命令</span><br><span class="line">CMD [&quot;.&#x2F;my-http-server&quot;]</span><br></pre></td></tr></table></figure><p>将上述Dockerfile保存到您的项目目录中，并在终端中导航到该目录。然后，运行以下命令以构建Docker镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-http-server .</span><br></pre></td></tr></table></figure><p>其中，“my-http-server”是您给镜像取的名称，最后的句点表示使用当前目录中的Dockerfile进行构建。</p><p>构建完成后，您可以运行以下命令以在容器中启动您的HTTP服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 10522:10522 my-http-server</span><br></pre></td></tr></table></figure><p>其中，“10522:10522”表示将容器内的端口10522映射到主机的10522端口，以便可以通过主机的IP地址和端口号访问您的HTTP服务。</p><h3 id="二、在-CentOS-容器中预先部署-C-HTTP-服务，并将其打包为-Docker-镜像，以便将其交付给用户使用"><a href="#二、在-CentOS-容器中预先部署-C-HTTP-服务，并将其打包为-Docker-镜像，以便将其交付给用户使用" class="headerlink" title="二、在 CentOS 容器中预先部署 C++ HTTP 服务，并将其打包为 Docker 镜像，以便将其交付给用户使用"></a><strong>二、在 CentOS 容器中预先部署 C++ HTTP 服务，并将其打包为 Docker 镜像，以便将其交付给用户使用</strong></h3><ol><li>创建 CentOS 容器并登录：使用以下命令创建一个基于 CentOS 的 Docker 容器并登录：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name my-centos-container centos:latest</span><br></pre></td></tr></table></figure><ol><li>在 CentOS 容器中安装必要的软件：在容器内使用 yum 包管理器安装 C++ 编译器和所需的库，例如 boost 和 OpenSSL：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc-c++ boost boost-devel openssl-devel</span><br></pre></td></tr></table></figure><ol><li>复制应用程序到容器中：将编译好的二进制文件或源代码复制到容器中，可以使用 Docker 命令将应用程序复制到容器中：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp my-http-server my-centos-container:/app/</span><br></pre></td></tr></table></figure><p>其中，“my-http-server”是您的应用程序文件所在的路径。</p><ol><li>在容器中运行应用程序并测试：使用以下命令在容器中运行您的应用程序：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perlCopy code</span><br><span class="line">docker exec -it my-centos-container &#x2F;app&#x2F;my-http-server</span><br></pre></td></tr></table></figure><p>确保您的 HTTP 服务在容器中正常运行，并且您可以使用 curl 命令或 Web 浏览器测试您的应用程序。</p><ol><li>保存容器状态为镜像：使用以下命令将容器保存为 Docker 镜像：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit my-centos-container my-http-server-image</span><br></pre></td></tr></table></figure><p>其中，“my-http-server-image”是您给镜像取的名称。</p><ol><li>导出 Docker 镜像文件：使用以下命令将 Docker 镜像导出为 tar 文件：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save my-http-server-image &gt; my-http-server-image.tar</span><br></pre></td></tr></table></figure><ol><li>将 Docker 镜像交付给用户：将 tar 文件发送给用户，以便他们可以通过 Docker 命令加载您的应用程序：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; my-http-server-image.tar</span><br></pre></td></tr></table></figure><p>用户现在可以使用以下命令在本地 Docker 环境中运行您的应用程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 10522:10522 my-http-server-image /app/my-http-server</span><br></pre></td></tr></table></figure><p>其中，“10522:10522”表示将容器内的端口10522映射到主机的10522端口，以便可以通过主机的 IP 地址和端口号访问您的 HTTP 服务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、HTTP服务部署到Docker容器中创建一个Dockerfile&quot;&gt;&lt;a href=&quot;#一、HTTP服务部署到Docker容器中创建一个Dockerfile&quot; class=&quot;headerlink&quot; title=&quot;一、HTTP服务部署到Docker容器中创建一个</summary>
      
    
    
    
    <category term="linux" scheme="https://lennon.work/categories/linux/"/>
    
    
    <category term="基础知识" scheme="https://lennon.work/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="打包" scheme="https://lennon.work/tags/%E6%89%93%E5%8C%85/"/>
    
    <category term="linux" scheme="https://lennon.work/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>大神的gdb&amp;debug使用心得你学不学</title>
    <link href="https://lennon.work/2022/11/10/c++/%E5%A4%A7%E7%A5%9E%E7%9A%84gdb%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <id>https://lennon.work/2022/11/10/c++/%E5%A4%A7%E7%A5%9E%E7%9A%84gdb%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</id>
    <published>2022-11-10T01:52:34.513Z</published>
    <updated>2022-11-10T02:21:39.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、符号表"><a href="#一、符号表" class="headerlink" title="一、符号表"></a><strong>一、符号表</strong></h1><blockquote><p><em><strong>说明 gdb调试的前提是要有符号表。如果程序是release版本，符号表不全，则使用gdb调试时，不能单步调试，成员变量等信息不可查</strong></em></p></blockquote><h6 id="如何生成符号表"><a href="#如何生成符号表" class="headerlink" title="如何生成符号表"></a><strong>如何生成符号表</strong></h6><blockquote><p>编译代码时加上-g参数，则编译的程序中会带有当前程序的符号表。<br>如 gcc -o main main.c，则可对main程序进行单步调试</p></blockquote><hr><h1 id="二、调试"><a href="#二、调试" class="headerlink" title="二、调试"></a><strong>二、调试</strong></h1><blockquote><p>假设有一进程test<br>gdb test //调试某一可执行程序<br>run(简写为r) //运行进程，假设有入参，则运行run argv</p></blockquote><hr><h1 id="三、断点相关"><a href="#三、断点相关" class="headerlink" title="三、断点相关"></a><strong>三、断点相关</strong></h1><h6 id="1-设置断点"><a href="#1-设置断点" class="headerlink" title="1.设置断点"></a><strong>1.设置断点</strong></h6><p><strong><em>设置断点的命令为</em>b</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）b function 将函数function设置为断点</span><br><span class="line">2）b test.c:100 将文件的第100行设置为断点</span><br><span class="line">3）b test.c:100 if tt &#x3D; 1 将文件test.c的第100行作为断点，当tt等于1时停止</span><br></pre></td></tr></table></figure><h6 id="2，查看当前断点信息-info-b"><a href="#2，查看当前断点信息-info-b" class="headerlink" title="2，查看当前断点信息 info b"></a><strong>2，查看当前断点信息 info b</strong></h6><h6 id="3，删除当前断点信息-delete-1-delete加断点的number-或者用d-1"><a href="#3，删除当前断点信息-delete-1-delete加断点的number-或者用d-1" class="headerlink" title="3，删除当前断点信息 delete 1 delete加断点的number,或者用d 1"></a><strong>3，删除当前断点信息 delete 1 delete加断点的number,或者用d 1</strong></h6><h6 id="4，使当前断点失效-disable-1-如果断点已失效-用enable-1时断点1继续生效"><a href="#4，使当前断点失效-disable-1-如果断点已失效-用enable-1时断点1继续生效" class="headerlink" title="4，使当前断点失效 disable 1 如果断点已失效 用enable 1时断点1继续生效"></a><strong>4，使当前断点失效 disable 1 如果断点已失效 用enable 1时断点1继续生效</strong></h6><h6 id="5，清除所有断点-clear"><a href="#5，清除所有断点-clear" class="headerlink" title="5，清除所有断点 clear"></a><strong>5，清除所有断点 clear</strong></h6><hr><h1 id="四、打印变量的值"><a href="#四、打印变量的值" class="headerlink" title="四、打印变量的值"></a><strong>四、打印变量的值</strong></h1><h6 id="1，print-i-简写为p打印变量i的值"><a href="#1，print-i-简写为p打印变量i的值" class="headerlink" title="1，print i 简写为p打印变量i的值"></a><strong>1，print i 简写为p打印变量i的值</strong></h6><p><strong>2，p/x i 以十六进制打印变量i的值 八进制（o）,二进制（t）</strong></p><hr><h1 id="五、调试基本命令"><a href="#五、调试基本命令" class="headerlink" title="五、调试基本命令"></a><strong>五、调试基本命令</strong></h1><h6 id="1，bt-查看当前栈空间信息"><a href="#1，bt-查看当前栈空间信息" class="headerlink" title="1，bt 查看当前栈空间信息"></a><strong>1，bt 查看当前栈空间信息</strong></h6><h6 id="2，next-简写为n-进行单步调试"><a href="#2，next-简写为n-进行单步调试" class="headerlink" title="2，next 简写为n 进行单步调试"></a><strong>2，next 简写为n 进行单步调试</strong></h6><h6 id="3，step-简写为s-遇到函数时进入函数"><a href="#3，step-简写为s-遇到函数时进入函数" class="headerlink" title="3，step 简写为s 遇到函数时进入函数"></a><strong>3，step 简写为s 遇到函数时进入函数</strong></h6><h6 id="4，finish-结束当前函数"><a href="#4，finish-结束当前函数" class="headerlink" title="4，finish 结束当前函数"></a><strong>4，finish 结束当前函数</strong></h6><h6 id="5，continue-简写为c，遇到断点继续执行用c-；c-3，忽略断点，直到第三次碰到断点"><a href="#5，continue-简写为c，遇到断点继续执行用c-；c-3，忽略断点，直到第三次碰到断点" class="headerlink" title="5，continue 简写为c，遇到断点继续执行用c ；c 3，忽略断点，直到第三次碰到断点"></a><strong>5，continue 简写为c，遇到断点继续执行用c ；c 3，忽略断点，直到第三次碰到断点</strong></h6><h6 id="6，untill-简写为u，循环体直接退出"><a href="#6，untill-简写为u，循环体直接退出" class="headerlink" title="6，untill 简写为u，循环体直接退出"></a><strong>6，untill 简写为u，循环体直接退出</strong></h6><h6 id="7，set-i-1-当前断点处设置变量i的值为1"><a href="#7，set-i-1-当前断点处设置变量i的值为1" class="headerlink" title="7，set i = 1 当前断点处设置变量i的值为1"></a><strong>7，set i = 1 当前断点处设置变量i的值为1</strong></h6><h6 id="8，info-locals-显示当前所有局部变量"><a href="#8，info-locals-显示当前所有局部变量" class="headerlink" title="8，info locals 显示当前所有局部变量"></a><strong>8，info locals 显示当前所有局部变量</strong></h6><hr><h1 id="六、稍微高级点的用法"><a href="#六、稍微高级点的用法" class="headerlink" title="六、稍微高级点的用法"></a><strong>六、稍微高级点的用法</strong></h1><h6 id="1，command"><a href="#1，command" class="headerlink" title="1，command"></a><strong>1，command</strong></h6><blockquote><p><strong>在断点处做处理，如下图，当i=5时，attach.c的第16行停住，执行的命令时打印i的值</strong><br><strong>command后面加数字代表的是对某个断点做command</strong></p><p><strong><img src="/img/c++/gdb/1.png" alt="command"></strong></p></blockquote><h6 id="2，-frame-2-跳到2号栈框"><a href="#2，-frame-2-跳到2号栈框" class="headerlink" title="2， frame 2 跳到2号栈框"></a><strong>2， frame 2 跳到2号栈框</strong></h6><p><strong><img src="/img/c++/gdb/2.png" alt="frame "></strong></p><h6 id="3，-数组打印用-，假设需要打印10个字符，变量为tt，则p-10"><a href="#3，-数组打印用-，假设需要打印10个字符，变量为tt，则p-10" class="headerlink" title="3，@ 数组打印用@，假设需要打印10个字符，变量为tt，则p@10"></a><strong>3，@ 数组打印用@，假设需要打印10个字符，变量为tt，则p@10</strong></h6><h6 id="4，call-执行某个函数时用"><a href="#4，call-执行某个函数时用" class="headerlink" title="4，call 执行某个函数时用"></a><strong>4，call 执行某个函数时用</strong></h6><p><strong><img src="/img/c++/gdb/3.png" alt="call "></strong></p><h6 id="6，set-follow-fork-mode-child-parent-当fork子进程需要跟子进程时用，或跟进父进程使用"><a href="#6，set-follow-fork-mode-child-parent-当fork子进程需要跟子进程时用，或跟进父进程使用" class="headerlink" title="6，set follow-fork-mode child/parent 当fork子进程需要跟子进程时用，或跟进父进程使用"></a><strong>6，set follow-fork-mode child/parent 当fork子进程需要跟子进程时用，或跟进父进程使用</strong></h6><h6 id="7，gdb-attach-xx-跟进正在运行pid为xxx的程序"><a href="#7，gdb-attach-xx-跟进正在运行pid为xxx的程序" class="headerlink" title="7，gdb attach xx 跟进正在运行pid为xxx的程序"></a><strong>7，gdb attach xx 跟进正在运行pid为xxx的程序</strong></h6><h6 id="8，jump-gdb可以改变程序的运行顺序"><a href="#8，jump-gdb可以改变程序的运行顺序" class="headerlink" title="8，jump gdb可以改变程序的运行顺序"></a><strong>8，jump gdb可以改变程序的运行顺序</strong></h6><blockquote><p><strong>jump test.c:10 直接跳转到test.c的第10行运行，跳过中间代码</strong><br><strong>jump +10 直接跳转到当前断点后的第10行，跳过中间代码</strong></p></blockquote><h6 id="9，return-强制返回，剩余代码不再还行"><a href="#9，return-强制返回，剩余代码不再还行" class="headerlink" title="9，return 强制返回，剩余代码不再还行"></a><strong>9，return 强制返回，剩余代码不再还行</strong></h6><h6 id="10-up-上移栈针，使上一个函数成为当前函数"><a href="#10-up-上移栈针，使上一个函数成为当前函数" class="headerlink" title="10, up 上移栈针，使上一个函数成为当前函数"></a><strong>10, up 上移栈针，使上一个函数成为当前函数</strong></h6><hr><h1 id="七、多线程调试"><a href="#七、多线程调试" class="headerlink" title="七、多线程调试"></a><strong>七、多线程调试</strong></h1><ul><li><strong>info thread 查看所有线程信息</strong></li><li><strong>thread x 将程序跳到线程x的栈框</strong></li><li><strong>break thread_test.c:123 thread all 在所有线程中相应的行上设置断点</strong></li><li><strong>set scheduler-locking off|on 锁定当前线程，只调试当前线程</strong></li></ul><hr><h1 id="八、其他"><a href="#八、其他" class="headerlink" title="八、其他"></a><strong>八、其他</strong></h1><ul><li><strong>list function 显示某个函数的源码</strong></li><li><strong>list 显示当前行后面的源程序</strong></li><li><strong>list - 显示当前行前面的源程序</strong></li><li><strong>show listsize 查看当前listsize的设置。</strong></li><li><strong>set listsize count 设置一次显示源代码的行数</strong></li></ul><h1 id="九、实战应用"><a href="#九、实战应用" class="headerlink" title="九、实战应用"></a>九、实战应用</h1><ul><li><strong>strace -f -tt -p [pid] -f 跟踪所有子进程和线程 -tt可以显示时间</strong></li><li><strong>top -Hp [pid] 可以查看一个进程所有线程的cpu使用情况</strong></li><li><strong>pstack [pid] 可以查看进程所有线程的调用栈</strong></li><li><strong>gdb， attach  [pid]、info threads、thread [thread num]查看调用栈</strong></li><li><strong>strace -f -tt -c -p [pid] 加上-c 可以查看一定时间内系统调用的统计</strong></li><li><strong>ltrace -p [pid] 查看进程调用库函数的</strong></li></ul><p><strong>————————————————</strong><br><strong>版权声明：本文为CSDN博主「qq_23953675」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</strong><br><strong>原文链接：<a href="https://blog.csdn.net/qq_23953675/article/details/106116247">https://blog.csdn.net/qq_23953675/article/details/106116247</a></strong><br><strong>原文链接：<a href="https://blog.csdn.net/qq_23953675/article/details/105291724">https://blog.csdn.net/qq_23953675/article/details/105291724</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、符号表&quot;&gt;&lt;a href=&quot;#一、符号表&quot; class=&quot;headerlink&quot; title=&quot;一、符号表&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、符号表&lt;/strong&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;说明 gdb调试的前提是要有符号</summary>
      
    
    
    
    <category term="c++" scheme="https://lennon.work/categories/c/"/>
    
    
    <category term="c++" scheme="https://lennon.work/tags/c/"/>
    
    <category term="gdb - 调试" scheme="https://lennon.work/tags/gdb-%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>系统信息提取（一）</title>
    <link href="https://lennon.work/2022/04/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/systeminfo/"/>
    <id>https://lennon.work/2022/04/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/systeminfo/</id>
    <published>2022-04-08T08:21:52.900Z</published>
    <updated>2022-04-08T10:55:51.468Z</updated>
    
    <content type="html"><![CDATA[<h3 id="系统信息获取"><a href="#系统信息获取" class="headerlink" title="系统信息获取"></a>系统信息获取</h3><h4 id="网络连接信息"><a href="#网络连接信息" class="headerlink" title="网络连接信息"></a>网络连接信息</h4><p>win getadaptersInfo获取取网卡详细信息</p><p>linux  通过套接字获取</p><p><a href="https://www.codeleading.com/article/70412911584/">https://www.codeleading.com/article/70412911584/</a></p><p>主机名</p><p>win:  调用ntdll.dll获取RtlGetVersion方法、Kernel32.dll获取GetNativeSystemInfo方法。判断主版本号</p><p>linux :读取 /etc/redhat-release 、/etc/issue 、/etc/SuSe-release获取，判断是否带桌面，读取/etc/os</p><p>-release查看是否含有uos、uniontech os、kylin,并查看uname -a查看含有desktop。</p><p><a href="https://blog.csdn.net/qq125096885/article/details/60870846">https://blog.csdn.net/qq125096885/article/details/60870846</a></p><p>处理器型号</p><p>win 读取注册表 <img src="C:\Users\Lennon\AppData\Roaming\Typora\typora-user-images\image-20220408164046173.png" alt="image-20220408164046173"></p><p>linux  读取/proc/cpuinfo</p><p>主板号</p><p>win kernel32获取GetSystemFirmwareTable</p><p>linux 执行./dmidecode 查看Base Board Informations</p><p>获取物理内存</p><p>win GlobalMemoryStatusEx </p><p>Linux  pstat_getstatic获取静态内存页数 、pstat_getdynamic获取动态页数</p><p>获取显卡信息</p><p>linux ./dmidecode 查看Type：video</p><p>win 查询注册表<img src="C:\Users\Lennon\AppData\Roaming\Typora\typora-user-images\image-20220408165559821.png" alt="image-20220408165559821"></p><p>获取内核版本信息</p><p>win 调用ntdll.dll获取RtlGetVersion方法</p><p>linux  uname</p><p>获取pcname</p><p>linux /etc/sysconfig/network // /etc/hostname  </p><p>win getcomputerNameA</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;系统信息获取&quot;&gt;&lt;a href=&quot;#系统信息获取&quot; class=&quot;headerlink&quot; title=&quot;系统信息获取&quot;&gt;&lt;/a&gt;系统信息获取&lt;/h3&gt;&lt;h4 id=&quot;网络连接信息&quot;&gt;&lt;a href=&quot;#网络连接信息&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="网络安全" scheme="https://lennon.work/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="system" scheme="https://lennon.work/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>13. 马数字转整数</title>
    <link href="https://lennon.work/2021/07/04/leetcode/leetcode13/"/>
    <id>https://lennon.work/2021/07/04/leetcode/leetcode13/</id>
    <published>2021-07-04T08:06:27.437Z</published>
    <updated>2021-07-04T08:12:04.440Z</updated>
    
    <content type="html"><![CDATA[<h3 id="leetcode题库-43-字符串相乘"><a href="#leetcode题库-43-字符串相乘" class="headerlink" title="leetcode题库 43. 字符串相乘"></a>leetcode题库 43. 字符串相乘</h3><hr><h4 id="原题信息"><a href="#原题信息" class="headerlink" title="原题信息"></a>原题信息</h4><hr><h5 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接:"></a>原题链接:</h5><blockquote><p><a href="https://leetcode-cn.com/problems/roman-to-integer/">https://leetcode-cn.com/problems/roman-to-integer/</a></p></blockquote><hr><h5 id="难度等级"><a href="#难度等级" class="headerlink" title="难度等级"></a>难度等级</h5><blockquote><p>中等</p></blockquote><hr><h5 id="原题描述"><a href="#原题描述" class="headerlink" title="原题描述"></a>原题描述</h5><blockquote><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p></blockquote><p><img src="/img/lennon13/example.png" alt="example1"></p><hr><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><hr><h5 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h5><blockquote></blockquote><hr><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dojob</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;last, <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;sum, <span class="keyword">unsigned</span> <span class="keyword">int</span> tnew)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tnew &gt; last) &#123;</span><br><span class="line">sum += (tnew - <span class="number">2</span> * last);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">sum += tnew;</span><br><span class="line">&#125;</span><br><span class="line">last = tnew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> last = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> w : s) &#123;</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (w) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="built_in">dojob</span>(last, sum,<span class="number">1000</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: <span class="built_in">dojob</span>(last, sum, <span class="number">500</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="built_in">dojob</span>(last, sum, <span class="number">100</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: <span class="built_in">dojob</span>(last, sum, <span class="number">50</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>: <span class="built_in">dojob</span>(last, sum, <span class="number">10</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="built_in">dojob</span>(last, sum, <span class="number">5</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>: <span class="built_in">dojob</span>(last, sum, <span class="number">1</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;what fuck!&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h5 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h5><p><a href="https://github.com/lennon-liu/leetcode/tree/main/lennon13">https://github.com/lennon-liu/leetcode/tree/main/lennon13</a></p><hr><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p><img src="/img/lennon13/lennon13_re.png" alt="lennon2"></p><hr><h4 id="优化与总结"><a href="#优化与总结" class="headerlink" title="优化与总结"></a>优化与总结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><hr><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers">https://leetcode-cn.com/problems/add-two-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;leetcode题库-43-字符串相乘&quot;&gt;&lt;a href=&quot;#leetcode题库-43-字符串相乘&quot; class=&quot;headerlink&quot; title=&quot;leetcode题库 43. 字符串相乘&quot;&gt;&lt;/a&gt;leetcode题库 43. 字符串相乘&lt;/h3&gt;&lt;hr</summary>
      
    
    
    
    <category term="leetcode" scheme="https://lennon.work/categories/leetcode/"/>
    
    
    <category term="简单难度" scheme="https://lennon.work/tags/%E7%AE%80%E5%8D%95%E9%9A%BE%E5%BA%A6/"/>
    
    <category term="c++实现" scheme="https://lennon.work/tags/c-%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="字符串" scheme="https://lennon.work/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>C++学习 关联容器测试代码</title>
    <link href="https://lennon.work/2021/06/15/cplusplus/%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F%E4%B8%8Emultiset%E6%B5%8B%E8%AF%95/"/>
    <id>https://lennon.work/2021/06/15/cplusplus/%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F%E4%B8%8Emultiset%E6%B5%8B%E8%AF%95/</id>
    <published>2021-06-15T07:57:52.216Z</published>
    <updated>2021-06-15T08:02:10.557Z</updated>
    
    <content type="html"><![CDATA[<p>customized_set ：自定义set内类型、erase、遍历、关系函数</p><p>customized_multiset ：自定义multiset内类型、erase、遍历、关系函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//============================================================================</span></span><br><span class="line"><span class="comment">// Name        : multi_set_te.cpp</span></span><br><span class="line"><span class="comment">// Author      : </span></span><br><span class="line"><span class="comment">// Version     :</span></span><br><span class="line"><span class="comment">// Copyright   : </span></span><br><span class="line"><span class="comment">// Description : </span></span><br><span class="line"><span class="comment">//============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Struct</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span><span class="params">(*s_compare_1)</span><span class="params">(<span class="keyword">const</span> Struct &amp;,<span class="keyword">const</span> Struct &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">s_compare</span><span class="params">(<span class="keyword">const</span> Struct &amp; s1,<span class="keyword">const</span> Struct &amp;s2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s1.a &lt; s2.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">s_compare_2</span><span class="params">(<span class="keyword">const</span> Struct &amp; s1,<span class="keyword">const</span> Struct &amp;s2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s1.a &lt;= s2.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span> &lt;&lt;(std::ostream&amp; os,<span class="keyword">const</span> Struct &amp; s1)&#123;</span><br><span class="line"><span class="keyword">return</span> os&lt;&lt;s1.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">customized_multiset</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//multiset&lt;Struct,decltype(s_compare) *&gt; ms(s_compare);</span></span><br><span class="line">multiset&lt;Struct,s_compare_1&gt; ms(s_compare);</span><br><span class="line">ms.<span class="built_in">insert</span>(&#123;<span class="number">5</span>&#125;);</span><br><span class="line">ms.<span class="built_in">insert</span>(&#123;<span class="number">10</span>&#125;);</span><br><span class="line">ms.<span class="built_in">insert</span>(&#123;<span class="number">20</span>&#125;);</span><br><span class="line">ms.<span class="built_in">insert</span>(&#123;<span class="number">5</span>&#125;);</span><br><span class="line"><span class="comment">//multiset&lt;Struct,decltype(s_compare) *&gt;::const_iterator ms_cit = ms.begin();</span></span><br><span class="line">multiset&lt;Struct,s_compare_1&gt;::const_iterator ms_cit = ms.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(;ms_cit!=ms.<span class="built_in">end</span>();ms_cit++)&#123;</span><br><span class="line">cout&lt;&lt;*ms_cit&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;ms delete erase after&quot;</span>&lt;&lt;endl;</span><br><span class="line">ms.<span class="built_in">erase</span>(&#123;<span class="number">5</span>&#125;);</span><br><span class="line"><span class="comment">//multiset&lt;Struct,decltype(s_compare) *&gt;::const_iterator ms_cit = ms.begin();</span></span><br><span class="line">ms_cit = ms.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(;ms_cit!=ms.<span class="built_in">end</span>();ms_cit++)&#123;</span><br><span class="line">cout&lt;&lt;*ms_cit&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">customized_set</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//multiset&lt;Struct,decltype(s_compare) *&gt; ms(s_compare);</span></span><br><span class="line">set&lt;Struct,s_compare_1&gt; ms(s_compare);</span><br><span class="line"><span class="comment">//set&lt;Struct,s_compare_1&gt; ms(s_compare_2);</span></span><br><span class="line">ms.<span class="built_in">insert</span>(&#123;<span class="number">5</span>&#125;);</span><br><span class="line">ms.<span class="built_in">insert</span>(&#123;<span class="number">10</span>&#125;);</span><br><span class="line">ms.<span class="built_in">insert</span>(&#123;<span class="number">20</span>&#125;);</span><br><span class="line">ms.<span class="built_in">insert</span>(&#123;<span class="number">5</span>&#125;);</span><br><span class="line"><span class="comment">//multiset&lt;Struct,decltype(s_compare) *&gt;::const_iterator ms_cit = ms.begin();</span></span><br><span class="line">multiset&lt;Struct,s_compare_1&gt;::const_iterator ms_cit = ms.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(;ms_cit!=ms.<span class="built_in">end</span>();ms_cit++)&#123;</span><br><span class="line">cout&lt;&lt;*ms_cit&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vector2set2vector</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nums[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(nums,nums+<span class="number">12</span>)</span></span>;</span><br><span class="line"><span class="function">set&lt;<span class="keyword">int</span>&gt; <span class="title">st</span><span class="params">(vec.begin(), vec.end())</span></span>;</span><br><span class="line">vec.<span class="built_in">assign</span>(st.<span class="built_in">begin</span>(), st.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); it++)</span><br><span class="line">cout &lt;&lt; *it&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//customized_set();</span></span><br><span class="line"><span class="comment">//customized_multiset();</span></span><br><span class="line"><span class="built_in">vector2set2vector</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;customized_set ：自定义set内类型、erase、遍历、关系函数&lt;/p&gt;
&lt;p&gt;customized_multiset ：自定义multiset内类型、erase、遍历、关系函数&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table</summary>
      
    
    
    
    <category term="C++" scheme="https://lennon.work/categories/C/"/>
    
    
    <category term="c++" scheme="https://lennon.work/tags/c/"/>
    
    <category term="基础知识" scheme="https://lennon.work/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="概念必备" scheme="https://lennon.work/tags/%E6%A6%82%E5%BF%B5%E5%BF%85%E5%A4%87/"/>
    
  </entry>
  
  <entry>
    <title>C++学习 关联容器</title>
    <link href="https://lennon.work/2021/06/15/cplusplus/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    <id>https://lennon.work/2021/06/15/cplusplus/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</id>
    <published>2021-06-15T07:57:52.214Z</published>
    <updated>2021-06-23T08:19:32.321Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><p>容器分为顺序容器和关联容器，他们之间存在根本的区别，联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。，主要顺序容器有vector、list、string、deque。主要的的关联容器有set、map。</p><p><img src="/img/cplusplus/stru.jpg" alt="img"></p><p><img src="/img/cplusplus/03.png" alt="微信截图_20210623133303"></p><hr><h4 id="关联容器之map"><a href="#关联容器之map" class="headerlink" title="关联容器之map"></a>关联容器之map</h4><p>map 由红黑树实现，其元素都是 “键值/实值” 所形成的一个对组（key/value pairs)， 插入和搜索的平均复杂度均为<code>O(log(size))</code>。每个元素有一个键，是排序准则的基础。每一个键只能出现一次，不允许重复。字典则是一个很好的使用map的例子：可以将单词作为关键字，将单词释义作为值。</p><p>map类型通常被称为关联数组。</p><p><strong>对于迭代器来说，可以修改实值，而不能修改 key。</strong></p><h5 id="map引申类型"><a href="#map引申类型" class="headerlink" title="map引申类型"></a>map引申类型</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map ：关联数组；保存关键字-值对；数据的存放是有序的</span><br><span class="line">multimap：关键字可以重复出现的map</span><br><span class="line">unordered_map：用哈希函数组织的map；容器中的数据存放是无序的</span><br><span class="line">unordered_multimap：哈希组织的map；关键字可以重复出现</span><br></pre></td></tr></table></figure><p><u>需要注意的是：类型map和multimap定义在头文件map中，unordered_map定义在头文件unordered_map中。</u></p><h5 id="map的相关定义"><a href="#map的相关定义" class="headerlink" title="map的相关定义"></a>map的相关定义</h5><p>类似顺序容器，关联容器也是模板。当定义一个map时，必须指明关键字类型又指明值类型。每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器。我们也可以将关联容器初始化为另一个同类型容器的拷贝，或是从一个值范围来初始化关联容器，只要这些值可以转化为容器所需类型就可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,<span class="keyword">size_t</span>&gt; word_count;  <span class="comment">//string到size_t的空map</span></span><br><span class="line">map&lt;string,string&gt; authors1=&#123;&#123;<span class="string">&quot;Joyce&quot;</span>,<span class="string">&quot;James&quot;</span>&#125;,&#123;<span class="string">&quot;Austen&quot;</span>,<span class="string">&quot;Jane&quot;</span>&#125;&#125;;</span><br><span class="line">map&lt;string,string&gt;  authors2=authors1;</span><br></pre></td></tr></table></figure><h5 id="map容器定义了如下列出的类型，这些类型表示容器关键字和值的类型。"><a href="#map容器定义了如下列出的类型，这些类型表示容器关键字和值的类型。" class="headerlink" title="map容器定义了如下列出的类型，这些类型表示容器关键字和值的类型。"></a><strong>map容器定义了如下列出的类型，这些类型表示容器关键字和值的类型。</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key_type        map容器的关键字的类型 </span><br><span class="line">mapped_type     每个关键字对应的值的类型 </span><br><span class="line">value_type      为pair&lt;<span class="keyword">const</span> key_type,mapped_type&gt;</span><br></pre></td></tr></table></figure><h5 id="容器关键词的定义与使用"><a href="#容器关键词的定义与使用" class="headerlink" title="容器关键词的定义与使用"></a><strong>容器关键词的定义与使用</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,<span class="keyword">int</span>&gt;::value_type v1;   <span class="comment">//v1是一个pair&lt;const string,int&gt;</span></span><br><span class="line">map&lt;string,<span class="keyword">int</span>&gt;::key_type v2;     <span class="comment">//v2是一个string</span></span><br><span class="line">map&lt;string,<span class="keyword">int</span>&gt;::mapped_type v3;   <span class="comment">//v3是一个int</span></span><br></pre></td></tr></table></figure><h5 id="map的使用"><a href="#map的使用" class="headerlink" title="map的使用"></a>map的使用</h5><p> 当我们向顺序容器比如vector中插入元素时，我们可以使用push_back()函数将数据插入到容器尾部。但是关联容器不支持push_back()和push_front()的操作，所以我们想要往map中插入数据时，只能使用insert和emplace函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">insert</span>(v)          v是value_type类型的对象</span><br><span class="line">c.<span class="built_in">emplace</span>(args)      args用来构造一个value_type类型的对象</span><br><span class="line">c.<span class="built_in">insert</span>(b,e)        b,e是迭代器，表示一个c::value_type类型值的范围</span><br><span class="line">c.<span class="built_in">insert</span>(il)         il代表花括号列表，花括号里是一个pair</span><br><span class="line">c.<span class="built_in">insert</span>(p,v)        类似<span class="built_in">insert</span>(v)，迭代器p指出从哪里开始搜索新元素应该存储的位置</span><br><span class="line">c.<span class="built_in">emplace</span>(p,args)    类似<span class="built_in">emplace</span>(args)，迭代器p指出从哪里开始搜索新元素应该存储的位置</span><br></pre></td></tr></table></figure><h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a><strong>遍历</strong></h5><p>当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用。对map容器而言，它的迭代器其实指向的是一个pair类型的对象。我们可以使用迭代器遍历map容器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> map_it=word_count.<span class="built_in">cbegin</span>();</span><br><span class="line"><span class="keyword">for</span>(map_it;map_it!=word_count.<span class="built_in">cend</span>();map_it++)</span><br><span class="line">   cout&lt;&lt;map_it-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;map_it-&gt;second&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h5 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a><strong>访问元素</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = word_count.<span class="built_in">find</span>(<span class="string">&quot;foobar&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(it==word_count.<span class="built_in">end</span>())</span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;foobar is not in the map&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   cout&lt;&lt;it-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a><strong>删除元素</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.erase(key)   &#x2F;&#x2F;从c中删除关键字为key的元素。返回一个size_type的值，指出删除元素数量</span><br><span class="line">c.erase(iterator_p)   &#x2F;&#x2F;从c中删除迭代器p指定的元素。</span><br><span class="line">c.erase(iterator_b,iterator_e) &#x2F;&#x2F;删除迭代器b和e表示的范围中的元素。返回e</span><br></pre></td></tr></table></figure><h5 id="优缺点和适用场景"><a href="#优缺点和适用场景" class="headerlink" title="优缺点和适用场景"></a><strong>优缺点和适用场景</strong></h5><p>优点：使用平衡二叉树实现，便于元素查找，且能把一个值映射成另一个值，可以创建字典。<br>缺点：每次插入值的时候，都需要调整红黑树，效率有一定影响。<br>适用场景：适用于需要存储一个数据字典，并要求方便地根据key找value的场景。</p><hr><h4 id="关联容器之multimap"><a href="#关联容器之multimap" class="headerlink" title="关联容器之multimap"></a><strong>关联容器之multimap</strong></h4><h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h5><h6 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a><strong>添加元素</strong></h6><p>由于multimap中容器的关键字不必唯一，所以我们可以向multimap中插入多个关键字相同的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;string,string&gt; authors;</span><br><span class="line">authors.<span class="built_in">insert</span>(&#123;<span class="string">&quot;ah&quot;</span>,<span class="string">&quot;my&quot;</span>&#125;);</span><br><span class="line">authors.<span class="built_in">insert</span>(&#123;<span class="string">&quot;ah&quot;</span>,<span class="string">&quot;mj&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><h6 id="下标访问"><a href="#下标访问" class="headerlink" title="下标访问"></a><strong>下标访问</strong></h6><p>map支持下标访问。multimap中的一个关键字可能对应多个值，所以multimap并不支持下标操作。</p><h6 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a><strong>查找元素</strong></h6><p>multimap一个关键字可能对应多个值，我们需要把这么对应的值都找出来。<br><strong>如果multimap中有多个元素具有相同的关键字，则这些关键字在容器中会相邻存储。</strong>我们可以通过这一特性，将一个关键字对应的多个值全部找出来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">search_item</span><span class="params">(<span class="string">&quot;Alain&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> numbers=authors.<span class="built_in">count</span>(search_item);</span><br><span class="line"><span class="keyword">auto</span> it=authors.<span class="built_in">find</span>(search_item);</span><br><span class="line"><span class="keyword">while</span>(numbers)</span><br><span class="line">&#123;</span><br><span class="line">   cout&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line">   ++it;</span><br><span class="line">   numbers--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="关联容器之set"><a href="#关联容器之set" class="headerlink" title="关联容器之set"></a>关联容器之set</h4><p>set：由红黑树实现，其内部元素依据其值自动排序，每个元素值只能出现一次，不允许重复，插入和搜索的平均复杂度均为O(log(size))。set 中的元素都是排好序的，集合中没有重复的元素。</p><h5 id="定义与初始化"><a href="#定义与初始化" class="headerlink" title="定义与初始化"></a><strong>定义与初始化</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string&gt; a1=&#123;<span class="string">&quot;fengxin&quot;</span>,<span class="string">&quot;666&quot;</span>&#125;;</span><br><span class="line">set&lt;string&gt; a2=a1;</span><br></pre></td></tr></table></figure><h5 id="添加与删除"><a href="#添加与删除" class="headerlink" title="添加与删除"></a><strong>添加与删除</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string&gt; a;  <span class="comment">//empty set</span></span><br><span class="line">a.<span class="built_in">insert</span>(<span class="string">&quot;fengxin&quot;</span>);  <span class="comment">// 插入一个元素</span></span><br><span class="line">a.<span class="built_in">emplace</span>(<span class="string">&quot;123&quot;</span>);   <span class="comment">//插入</span></span><br><span class="line">a.<span class="built_in">erase</span>(<span class="string">&quot;123&quot;</span>);    <span class="comment">//删除关键字为123的元素</span></span><br></pre></td></tr></table></figure><h5 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a><strong>遍历元素</strong></h5><p>同map容器类似。我们使用迭代器进行遍历set容器。需要注意的是，同不能改变一个map的关键字一样，一个set中的关键字也是const的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; iset=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it=iset.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">if</span>(it!=iset.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">     *it=<span class="number">10</span>;  <span class="comment">//错误：set中关键字是只读的</span></span><br><span class="line">     cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a><strong>查找</strong></h5><p>由于set中存储的只有关键字，所以set容器并不支持下标操作。<br>set同样可以使用find函数进行对关键字的查找，此时函数返回指向关键字的迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; iset=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it=iset.<span class="built_in">find</span>(<span class="number">6</span>);</span><br><span class="line">cout&lt;&lt;*it&lt;endl;</span><br></pre></td></tr></table></figure><hr><h5 id="优缺点和适用场景-1"><a href="#优缺点和适用场景-1" class="headerlink" title="优缺点和适用场景"></a><strong>优缺点和适用场景</strong></h5><p>优点：使用红黑树实现，便于元素查找，且保持了元素的唯一性，以及能自动排序。<br>缺点：每次插入值的时候，都需要调整红黑树，效率有一定影响。<br>适用场景：适用于经常查找一个元素是否在某群集中且需要排序的场景。</p><hr><h4 id="严格弱序"><a href="#严格弱序" class="headerlink" title="严格弱序"></a>严格弱序</h4><p><a href="https://blog.csdn.net/River_Lethe/article/details/78618788">C++ 严格弱序</a></p><p><a href="https://blog.csdn.net/qq_34801642/article/details/105726245?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242">C++ Primer：可以将严格弱序看作“小于等于”？</a></p><hr><h4 id="关联容器之pair"><a href="#关联容器之pair" class="headerlink" title="关联容器之pair"></a>关联容器之pair</h4><h5 id="pair定义"><a href="#pair定义" class="headerlink" title="pair定义"></a><strong>pair定义</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;T1, T2&gt; p1;            <span class="comment">//创建一个空的pair对象（使用默认构造），它的两个元素分别是T1和T2类型，采用值初始化。</span></span><br><span class="line">pair&lt;T1, T2&gt; p1(v1, v2);    //创建一个pair对象，它的两个元素分别是T1和T2类型，first成员初始化为v1，second成员初始化v2。</span><br><span class="line"><span class="built_in">make_pair</span>(v1, v2);          <span class="comment">// 以v1和v2的值创建一个新的pair对象，其元素类型分别是v1和v2的类型。</span></span><br><span class="line">p1 &lt; p2;                    <span class="comment">// 两个pair对象间的小于运算，其定义遵循字典次序：如 p1.first &lt; p2.first 或者 !(p2.first &lt; p1.first) &amp;&amp; (p1.second &lt; p2.second) 则返回true。</span></span><br><span class="line">p1 == p2；                  <span class="comment">// 如果两个对象的first和second依次相等，则这两个对象相等；该运算使用元素的==操作符。</span></span><br><span class="line">p1.first;                   <span class="comment">// 返回对象p1中名为first的公有数据成员</span></span><br><span class="line">p1.second;                 <span class="comment">// 返回对象p1中名为second的公有数据成员</span></span><br><span class="line">p1 relop p2                <span class="comment">// </span></span><br><span class="line">p1 == p2</span><br><span class="line">p1 != p2 </span><br></pre></td></tr></table></figure><h5 id="关联容器操作"><a href="#关联容器操作" class="headerlink" title="关联容器操作"></a><strong>关联容器操作</strong></h5><p><img src="/img/cplusplus/relation-types.png" alt="img"></p><hr><h4 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a><strong>无序关联容器</strong></h4><p>有序关联容器中的关键字是有序排列的，所以要求关键字可以进行&lt;运算符比较或满足自定义的比较操作。无序关联容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符。</p><p>无序容器可以使用上述所有的与有序容器相同的操作，由于无序容器在存储上组织为桶，每个桶保存零个或多个元素，容器的性能依赖于哈希函数的质量和桶的数量和大小，因此无序容器多了一些哈希函数和桶相关的操作。</p><h5 id="桶操作"><a href="#桶操作" class="headerlink" title="桶操作"></a>桶操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">bucket_count</span>()        正在使用的桶的数目</span><br><span class="line">m.<span class="built_in">max_bucket_count</span>()    容器能容纳的最多的桶的数量</span><br><span class="line">m.<span class="built_in">bucket_size</span>(n)        第n个桶中有多少个元素</span><br><span class="line">m.<span class="built_in">bucket</span>(k)             关键字为k的元素在哪个桶</span><br></pre></td></tr></table></figure><h5 id="桶迭代"><a href="#桶迭代" class="headerlink" title="桶迭代"></a>桶迭代</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local_iterator            可以用来访问桶中元素的迭代器类型</span><br><span class="line">const_local_iterator      桶迭代器的<span class="keyword">const</span>版本</span><br><span class="line">m.<span class="built_in">begin</span>(n)、m.<span class="built_in">end</span>(n)      桶n的首元素迭代器和尾后迭代器（n是什么类型？）</span><br><span class="line">m.<span class="built_in">cbegin</span>(n)、m.<span class="built_in">cend</span>(n)    与前两个函数类似，但返回const_local_iterator</span><br></pre></td></tr></table></figure><h5 id="哈希策略"><a href="#哈希策略" class="headerlink" title="哈希策略"></a>哈希策略</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个桶的平均元素数量，返回float值</span></span><br><span class="line">m.<span class="built_in">load_factor</span>() </span><br><span class="line"><span class="comment">//m试图维护的平均桶大小，返回float值，要求创建的新桶的load_factor&lt;=max_load_factor         </span></span><br><span class="line">m.<span class="built_in">max_load_factor</span>() </span><br><span class="line"><span class="comment">//重新存储，使得bucket_count&gt;=n，且bucket_count&gt;size/max_load_factor         </span></span><br><span class="line">m.<span class="built_in">rehash</span>(n)  </span><br><span class="line"><span class="comment">//重新存储，使得m可以保存n个元素且不必rehash </span></span><br><span class="line">m.<span class="built_in">reserve</span>(n) </span><br></pre></td></tr></table></figure><p>自定义类型</p><p>内置类型包括指针可以直接定义hash，因此可以直接定义内置类型的无需容器，但是不能直接定义自定义类类型的无需容器，需要自定义hash模板。</p><p><img src="https://images2018.cnblogs.com/blog/1272978/201806/1272978-20180610192953109-57405861.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> unordered_map&lt;string, <span class="keyword">double</span>&gt;::iterator MyIte;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">test_unordered_map</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line">     unordered_map&lt;string, <span class="keyword">double</span>&gt; umap;</span><br><span class="line">     umap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;苹果&quot;</span>, <span class="number">2.5</span>));</span><br><span class="line">     umap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;香蕉&quot;</span>, <span class="number">3.0</span>));</span><br><span class="line">     umap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;香蕉&quot;</span>, <span class="number">3.0</span>));</span><br><span class="line">     umap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;西瓜&quot;</span>, <span class="number">1.5</span>));</span><br><span class="line">     umap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;哈密瓜&quot;</span>, <span class="number">3.0</span>));</span><br><span class="line">     umap[<span class="string">&quot;榴莲&quot;</span>] = <span class="number">4.0</span>;</span><br><span class="line">     MyIte it = umap.<span class="built_in">begin</span>( );</span><br><span class="line">     <span class="keyword">while</span>( it != umap.<span class="built_in">end</span>( ))</span><br><span class="line">     &#123; </span><br><span class="line">         cout&lt;&lt;it-&gt;first&lt;&lt;<span class="string">&quot; :&quot;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;</span><br><span class="line">         ++it;</span><br><span class="line">     &#125;   </span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;桶数量：&quot;</span>&lt;&lt;umap.<span class="built_in">bucket_count</span>( )&lt;&lt;endl;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;负载因子：&quot;</span>&lt;&lt;umap.<span class="built_in">load_factor</span>( )&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//结果：</span></span><br><span class="line">    <span class="comment">//榴莲 :4</span></span><br><span class="line">    <span class="comment">//苹果 :2.5</span></span><br><span class="line">    <span class="comment">//哈密瓜 :3</span></span><br><span class="line">    <span class="comment">//香蕉 :3</span></span><br><span class="line">    <span class="comment">//西瓜 :1.5</span></span><br><span class="line">    <span class="comment">//桶数量：11</span></span><br><span class="line">    <span class="comment">//负载因子：0.454545</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="思考与总结"><a href="#思考与总结" class="headerlink" title="思考与总结"></a>思考与总结</h4><p>1、vector封装数组，list封装了链表，set, multiset, map, multimap内部采用的就是一种非常高效的平衡检索二叉树：红黑树。</p><p>2、<code>std::map</code>/<code>std::set</code>均为有序容器，这些元素内部通过红黑树进行实现， 插入和搜索的平均复杂度均为<code>O(log(size))</code>。在插入元素时候，会根据<code>&lt;</code>操作符比较元素大小并判断元素是否相同， 并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照<code>&lt;</code>操作符的顺序来逐个遍历。</p><p>空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间，对于那些有顺序要求的问题，用map会更高效一些。</p><p>map、set中查找是使用二分查找，对速度影响分析</p><p>insert、erase之后，已保存的iterator失效问题。</p><p>3、unordered_map 因为内部实现了哈希表，因此其查找速度非常的快，但是哈希表的建立比较耗费时间对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p><h4 id="相关代码："><a href="#相关代码：" class="headerlink" title="相关代码："></a>相关代码：</h4><p><a href="https://lennon.work/2021/06/15/cplusplus/%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F%E4%B8%8Emultiset%E6%B5%8B%E8%AF%95/">严格弱序与multiset测试</a></p><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p><a href="https://zhuanlan.zhihu.com/p/158647883">基础篇：STL容器和算法</a></p><p><a href="https://blog.csdn.net/fengxinlinux/article/details/73718859">c++关联容器总结</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;关联容器&quot;&gt;&lt;a href=&quot;#关联容器&quot; class=&quot;headerlink&quot; title=&quot;关联容器&quot;&gt;&lt;/a&gt;关联容器&lt;/h3&gt;&lt;p&gt;容器分为顺序容器和关联容器，他们之间存在根本的区别，联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它</summary>
      
    
    
    
    <category term="C++" scheme="https://lennon.work/categories/C/"/>
    
    
    <category term="c++" scheme="https://lennon.work/tags/c/"/>
    
    <category term="基础知识" scheme="https://lennon.work/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="概念必备" scheme="https://lennon.work/tags/%E6%A6%82%E5%BF%B5%E5%BF%85%E5%A4%87/"/>
    
  </entry>
  
  <entry>
    <title>C++学习 小贴士（一）</title>
    <link href="https://lennon.work/2021/04/22/cplusplus/constchar/"/>
    <id>https://lennon.work/2021/04/22/cplusplus/constchar/</id>
    <published>2021-04-22T10:55:52.854Z</published>
    <updated>2021-06-15T08:22:08.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-学习-小贴士（一）"><a href="#C-学习-小贴士（一）" class="headerlink" title="C++学习 小贴士（一）"></a>C++学习 小贴士（一）</h1><h2 id="const-char-p-amp-char-const-p-amp-const-char-const-p"><a href="#const-char-p-amp-char-const-p-amp-const-char-const-p" class="headerlink" title="const char* p &amp;  char* const p &amp; const char* const p"></a>const char* p &amp;  char* const p &amp; const char* const p</h2><p>最近学习c++中遇到一些小知识，没啥知识点，就是需要记住。</p><h4 id="const-char-p"><a href="#const-char-p" class="headerlink" title="const char* p"></a>const char* p</h4><p>解释 读作 non-const ponit 修饰 const value</p><p>因此不能通过指针修改value，可以修改 p本身。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> a = <span class="string">&#x27;A&#x27;</span>, b = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ptr = &amp;a;</span><br><span class="line">    <span class="comment">//*ptr = b; ierror</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value pointed to by ptr: %c\n&quot;</span>, *ptr);</span><br><span class="line">    ptr = &amp;b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value pointed to by ptr: %c\n&quot;</span>, *ptr);</span><br><span class="line">    <span class="comment">// ptr can be changed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="char-const-p"><a href="#char-const-p" class="headerlink" title="char* const p"></a>char* const p</h4><p>解释 读作 const ponit 修饰 non-const value</p><p>可以通过指针修改value吗，但是不能修改指针本身。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a = <span class="string">&#x27;A&#x27;</span>, b = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">const</span> ptr = &amp;a;</span><br><span class="line">    <span class="comment">//ptr = &amp;b; error</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value pointed to by ptr: %c\n&quot;</span>, *ptr);</span><br><span class="line">    *ptr = b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value pointed to by ptr: %c\n&quot;</span>, *ptr);</span><br><span class="line">    <span class="comment">// value can be changed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="const-char-const-p"><a href="#const-char-const-p" class="headerlink" title="const char* const p"></a>const char* const p</h4><p>解释 读作 const ponit 修饰 const value</p><p>顾名思义 point 和value 都加上了 const修饰，因此指针和值都不能修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a = <span class="string">&#x27;A&#x27;</span>, b = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">const</span> ptr = &amp;a;</span><br><span class="line">    <span class="comment">//ptr = &amp;b; error</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value pointed to by ptr: %c\n&quot;</span>, *ptr);</span><br><span class="line">    <span class="comment">//*ptr = b; error</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value pointed to by ptr: %c\n&quot;</span>, *ptr);</span><br><span class="line">    <span class="comment">// value can be changed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考来源：<a href="https://www.geeksforgeeks.org/difference-const-char-p-char-const-p-const-char-const-p/">https://www.geeksforgeeks.org/difference-const-char-p-char-const-p-const-char-const-p/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-学习-小贴士（一）&quot;&gt;&lt;a href=&quot;#C-学习-小贴士（一）&quot; class=&quot;headerlink&quot; title=&quot;C++学习 小贴士（一）&quot;&gt;&lt;/a&gt;C++学习 小贴士（一）&lt;/h1&gt;&lt;h2 id=&quot;const-char-p-amp-char-const</summary>
      
    
    
    
    <category term="C++" scheme="https://lennon.work/categories/C/"/>
    
    
    <category term="c++" scheme="https://lennon.work/tags/c/"/>
    
    <category term="基础知识" scheme="https://lennon.work/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="概念必备" scheme="https://lennon.work/tags/%E6%A6%82%E5%BF%B5%E5%BF%85%E5%A4%87/"/>
    
  </entry>
  
  <entry>
    <title>C++标准库及框架自学收藏</title>
    <link href="https://lennon.work/2021/04/18/cplusplus/resource/"/>
    <id>https://lennon.work/2021/04/18/cplusplus/resource/</id>
    <published>2021-04-18T13:10:07.974Z</published>
    <updated>2021-04-22T11:13:31.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-标准库及框架自学收藏"><a href="#C-标准库及框架自学收藏" class="headerlink" title="C++标准库及框架自学收藏"></a>C++标准库及框架自学收藏</h2><hr><p>标准库</p><p>C++标准库，包括了STL容器，算法和函数等。</p><ul><li>C++ Standard Library：是一系列类和函数的集合，使用核心语言编写，也是C++ISO自身标准的一部分。</li><li>Standard Template Library：标准模板库</li><li>C POSIX library ： POSIX系统的C标准库规范</li><li>ISO C++ Standards Committee ：C++标准委员会</li></ul><p>框架</p><p>C++通用框架和库</p><ul><li>Apache C++ Standard Library：是一系列算法，容器，迭代器和其他基本组件的集合</li><li>ASL ：Adobe源代码库提供了同行的评审和可移植的C++源代码库。</li><li>Boost ：大量通用C++库的集合。</li><li>BDE ：来自于彭博资讯实验室的开发环境。</li><li>Cinder：提供专业品质创造性编码的开源开发社区。</li><li>Cxxomfort：轻量级的，只包含头文件的库，将C++ 11的一些新特性移植到C++03中。</li><li>Dlib：使用契约式编程和现代C++科技设计的通用的跨平台的C++库。</li><li>EASTL ：EA-STL公共部分</li><li>ffead-cpp ：企业应用程序开发框架</li><li>Folly：由Facebook开发和使用的开源C++库</li><li>JUCE ：包罗万象的C++类库，用于开发跨平台软件</li><li>libPhenom：用于构建高性能和高度可扩展性系统的事件框架。</li><li>LibSourcey ：用于实时的视频流和高性能网络应用程序的C++11 evented IO</li><li>LibU ： C语言写的多平台工具库</li><li>Loki ：C++库的设计，包括常见的设计模式和习语的实现。</li><li>MiLi ：只含头文件的小型C++库</li><li>openFrameworks ：开发C++工具包，用于创意性编码。</li><li>Qt ：跨平台的应用程序和用户界面框架</li><li>Reason ：跨平台的框架，使开发者能够更容易地使用Java，.Net和Python，同时也满足了他们对C++性能和优势的需求。</li><li>ROOT ：具备所有功能的一系列面向对象的框架，能够非常高效地处理和分析大量的数据，为欧洲原子能研究机构所用。</li><li>STLport：是STL具有代表性的版本</li><li>STXXL：用于额外的大型数据集的标准模板库。</li><li>Ultimate++ ：C++跨平台快速应用程序开发框架</li><li>Windows Template Library：用于开发Windows应用程序和UI组件的C++库</li><li>Yomm11 ：C++11的开放multi-methods.</li></ul><p>人工智能</p><ul><li>btsk ：游戏行为树启动器工具</li><li>Evolving Objects：基于模板的，ANSI C++演化计算库，能够帮助你非常快速地编写出自己的随机优化算法。</li><li>Neu：C++11框架，编程语言集，用于创建人工智能应用程序的多用途软件系统。</li></ul><p>异步事件循环</p><ul><li>Boost.Asio：用于网络和底层I/O编程的跨平台的C++库。</li><li>libev ：功能齐全，高性能的时间循环，轻微地仿效libevent，但是不再像libevent一样有局限性，也修复了它的一些bug。</li><li>libevent ：事件通知库</li><li>libuv ：跨平台异步I/O。</li></ul><p>音频</p><p>音频，声音，音乐，数字化音乐库</p><ul><li>FMOD ：易于使用的跨平台的音频引擎和音频内容的游戏创作工具。</li><li>Maximilian ：C++音频和音乐数字信号处理库</li><li>OpenAL ：开源音频库—跨平台的音频API</li><li>Opus：一个完全开放的，免版税的，高度通用的音频编解码器</li><li>Speex：免费编解码器，为Opus所废弃</li><li>Tonic： C++易用和高效的音频合成</li><li>Vorbis： Ogg Vorbis是一种完全开放的，非专有的，免版税的通用压缩音频格式。</li></ul><p>生态学</p><p>生物信息，基因组学和生物技术</p><ul><li>libsequence：用于表示和分析群体遗传学数据的C++库。</li><li>SeqAn：专注于生物数据序列分析的算法和数据结构。</li><li>Vcflib ：用于解析和处理VCF文件的C++库</li><li>Wham：直接把联想测试应用到BAM文件的基因结构变异。</li></ul><p>压缩</p><p>压缩和归档库</p><ul><li>bzip2：一个完全免费，免费专利和高质量的数据压缩</li><li>doboz：能够快速解压缩的压缩库</li><li>PhysicsFS：对各种归档提供抽象访问的库，主要用于视频游戏，设计灵感部分来自于Quake3的文件子系统。</li><li>KArchive：用于创建，读写和操作文件档案（例如zip和 tar）的库，它通过QIODevice的一系列子类，使用gzip格式，提供了透明的压缩和解压缩的数据。</li><li>LZ4 ：非常快速的压缩算法</li><li>LZHAM ：无损压缩数据库，压缩比率跟LZMA接近，但是解压缩速度却要快得多。</li><li>LZMA ：7z格式默认和通用的压缩方法。</li><li>LZMAT ：及其快速的实时无损数据压缩库</li><li>miniz：单一的C源文件，紧缩/膨胀压缩库，使用zlib兼容API，ZIP归档读写，PNG写方式。</li><li>Minizip：Zlib最新bug修复，支持PKWARE磁盘跨越，AES加密和IO缓冲。</li><li>Snappy ：快速压缩和解压缩</li><li>ZLib ：非常紧凑的数据流压缩库</li><li>ZZIPlib：提供ZIP归档的读权限。</li></ul><p>并发性</p><p>并发执行和多线程</p><ul><li>Boost.Compute ：用于OpenCL的C++GPU计算库</li><li>Bolt ：针对GPU进行优化的C++模板库</li><li>C++React ：用于C++11的反应性编程库</li><li>Intel TBB ：Intel线程构件块</li><li>Libclsph：基于OpenCL的GPU加速SPH流体仿真库</li><li>OpenCL ：并行编程的异构系统的开放标准</li><li>OpenMP：OpenMP API</li><li>Thrust ：类似于C++标准模板库的并行算法库</li><li>HPX ：用于任何规模的并行和分布式应用程序的通用C++运行时系统</li><li>VexCL ：用于OpenCL/CUDA 的C++向量表达式模板库。</li></ul><p>容器</p><ul><li>C++ B-tree ：基于B树数据结构，实现命令内存容器的模板库</li><li>Hashmaps： C++中开放寻址哈希表算法的实现</li></ul><p>密码学</p><ul><li>Bcrypt ：一个跨平台的文件加密工具，加密文件可以移植到所有可支持的操作系统和处理器中。</li><li>BeeCrypt：</li><li>Botan： C++加密库</li><li>Crypto++：一个有关加密方案的免费的C++库</li><li>GnuPG： OpenPGP标准的完整实现</li><li>GnuTLS ：实现了SSL，TLS和DTLS协议的安全通信库</li><li>Libgcrypt</li><li>libmcrypt</li><li>LibreSSL：免费的SSL/TLS协议，属于2014 OpenSSL的一个分支</li><li>LibTomCrypt：一个非常全面的，模块化的，可移植的加密工具</li><li>libsodium：基于NaCI的加密库，固执己见，容易使用</li><li>Nettle 底层的加密库</li><li>OpenSSL ： 一个强大的，商用的，功能齐全的，开放源代码的加密库。</li><li>Tiny AES128 in C ：用C实现的一个小巧，可移植的实现了AES128ESB的加密算法</li></ul><p>数据库</p><p>数据库，SQL服务器，ODBC驱动程序和工具</p><ul><li>hiberlite ：用于Sqlite3的C++对象关系映射</li><li>Hiredis： 用于Redis数据库的很简单的C客户端库</li><li>LevelDB： 快速键值存储库</li><li>LMDB：符合数据库四大基本元素的嵌入键值存储</li><li>MySQL++：封装了MySql的C API的C++ 包装器</li><li>RocksDB：来自Facebook的嵌入键值的快速存储</li><li>SQLite：一个完全嵌入式的，功能齐全的关系数据库，只有几百KB，可以正确包含到你的项目中。</li></ul><p>调试</p><p>调试库， 内存和资源泄露检测，单元测试</p><ul><li>Boost.Test：Boost测试库</li><li>Catch：一个很时尚的，C++原生的框架，只包含头文件，用于单元测试，测试驱动开发和行为驱动开发。</li><li>CppUnit：由JUnit移植过来的C++测试框架</li><li>CTest：CMake测试驱动程序</li><li>googletest：谷歌C++测试框架</li><li>ig-debugheap：用于跟踪内存错误的多平台调试堆</li><li>libtap：用C语言编写测试</li><li>MemTrack —用于C++跟踪内存分配</li><li>microprofile- 跨平台的网络试图分析器</li><li>minUnit ：使用C写的迷你单元测试框架，只使用了两个宏</li><li>Remotery：用于web视图的单一C文件分析器</li><li>UnitTest++：轻量级的C++单元测试框架</li></ul><p>游戏引擎</p><ul><li>Cocos2d-x ：一个跨平台框架，用于构建2D游戏，互动图书，演示和其他图形应用程序。</li><li>Grit ：社区项目，用于构建一个免费的游戏引擎，实现开放的世界3D游戏。</li><li>Irrlicht ：C++语言编写的开源高性能的实时#D引擎</li><li>Polycode：C++实现的用于创建游戏的开源框架（与Lua绑定）。</li></ul><p>图形用户界面</p><ul><li>CEGUI ： 很灵活的跨平台GUI库</li><li>FLTK ：快速，轻量级的跨平台的C++GUI工具包。</li><li>GTK+： 用于创建图形用户界面的跨平台工具包</li><li>gtkmm ：用于受欢迎的GUI库GTK+的官方C++接口。</li><li>imgui：拥有最小依赖关系的立即模式图形用户界面</li><li>libRocket ：libRocket 是一个C++ HTML/CSS 游戏接口中间件</li><li>MyGUI ：快速，灵活，简单的GUI</li><li>Ncurses：终端用户界面</li><li>QCustomPlot ：没有更多依赖关系的Qt绘图控件</li><li>Qwt ：用户与技术应用的Qt 控件</li><li>QwtPlot3D ：功能丰富的基于Qt/OpenGL的C++编程库，本质上提供了一群3D控件</li><li>OtterUI ：OtterUI 是用于嵌入式系统和互动娱乐软件的用户界面开发解决方案</li><li>PDCurses 包含源代码和预编译库的公共图形函数库</li><li>wxWidgets C++库，允许开发人员使用一个代码库可以为widows， Mac OS X，Linux和其他平台创建应用程序</li></ul><p>图形</p><ul><li>bgfx：跨平台的渲染库</li><li>Cairo：支持多种输出设备的2D图形库</li><li>Horde3D 一个小型的3D渲染和动画引擎</li><li>magnum C++11和OpenGL 2D/3D 图形引擎</li><li>Ogre 3D 用C++编写的一个面向场景，实时，灵活的3D渲染引擎（并非游戏引擎）</li><li>OpenSceneGraph 具有高性能的开源3D图形工具包</li><li>Panda3D 用于3D渲染和游戏开发的框架，用Python和C++编写。</li><li>Skia 用于绘制文字，图形和图像的完整的2D图形库</li><li>urho3d 跨平台的渲染和游戏引擎。</li></ul><p>图像处理</p><ul><li>Boost.GIL：通用图像库</li><li>CImg ：用于图像处理的小型开源C++工具包</li><li>CxImage ：用于加载，保存，显示和转换的图像处理和转换库，可以处理的图片格式包括 BMP, JPEG, GIF, PNG, TIFF, MNG, ICO, PCX, TGA, WMF, WBMP, JBG, J2K。</li><li>FreeImage ：开源库，支持现在多媒体应用所需的通用图片格式和其他格式。</li><li>GDCM：Grassroots DICOM 库</li><li>ITK：跨平台的开源图像分析系统</li><li>Magick++：ImageMagick程序的C++接口</li><li>MagickWnd：ImageMagick程序的C++接口</li><li>OpenCV ： 开源计算机视觉类库</li><li>tesseract-ocr：OCR引擎</li><li>VIGRA ：用于图像分析通用C++计算机视觉库</li><li>VTK ：用于3D计算机图形学，图像处理和可视化的开源免费软件系统。</li></ul><p>国际化</p><ul><li>gettext ：GNU `gettext’</li><li>IBM ICU：提供Unicode 和全球化支持的C、C++ 和Java库</li><li>libiconv ：用于不同字符编码之间的编码转换库</li></ul><p>Jason</p><ul><li>frozen ： C/C++的Jason解析生成器</li><li>Jansson ：进行编解码和处理Jason数据的C语言库</li><li>jbson ：C++14中构建和迭代BSON data,和Json 文档的库</li><li>JeayeSON：非常健全的C++ JSON库，只包含头文件</li><li>JSON++ ： C++ JSON 解析器</li><li>json-parser：用可移植的ANSI C编写的JSON解析器，占用内存非常少</li><li>json11 ：一个迷你的C++11 JSON库</li><li>jute ：非常简单的C++ JSON解析器</li><li>ibjson：C语言中的JSON解析和打印库，很容易和任何模型集成。</li><li>libjson：轻量级的JSON库</li><li>PicoJSON：C++中JSON解析序列化，只包含头文件</li><li>qt-json ：用于JSON数据和 QVariant层次间的相互解析的简单类</li><li>QJson：将JSON数据映射到QVariant对象的基于Qt的库</li><li>RapidJSON： 用于C++的快速JSON 解析生成器，包含SAX和DOM两种风格的API</li><li>YAJL ：C语言中快速流JSON解析库</li></ul><p>日志</p><ul><li>Boost.Log ：设计非常模块化，并且具有扩展性</li><li>easyloggingpp：C++日志库，只包含单一的头文件。</li><li>Log4cpp ：一系列C++类库，灵活添加日志到文件，系统日志，IDSA和其他地方。</li><li>templog：轻量级C++库，可以添加日志到你的C++应用程序中</li></ul><p>机器学习</p><ul><li>Caffe ：快速的神经网络框架</li><li>CCV ：以C语言为核心的现代计算机视觉库</li><li>mlpack ：可扩展的C++机器学习库</li><li>OpenCV：开源计算机视觉库</li><li>Recommender：使用协同过滤进行产品推荐/建议的C语言库。</li><li>SHOGUN：Shogun 机器学习工具</li><li>sofia-ml ：用于机器学习的快速增量算法套件</li></ul><p>数学</p><ul><li>Armadillo ：高质量的C++线性代数库，速度和易用性做到了很好的平衡。语法和MatlAB很相似</li><li>blaze：高性能的C++数学库，用于密集和稀疏算法。</li><li>ceres-solver ：来自谷歌的C++库，用于建模和解决大型复杂非线性最小平方问题。</li><li>CGal： 高效，可靠的集合算法集合</li><li>cml ：用于游戏和图形的免费C++数学库</li><li>Eigen ：高级C++模板头文件库，包括线性代数，矩阵，向量操作，数值解决和其他相关的算法。</li><li>GMTL：数学图形模板库是一组广泛实现基本图形的工具。</li><li>GMP：用于个高精度计算的C/C++库，处理有符号整数，有理数和浮点数。</li></ul><p>多媒体</p><ul><li>GStreamer ：构建媒体处理组件图形的库</li><li>LIVE555 Streaming Media ：使用开放标准协议(RTP/RTCP, RTSP, SIP) 的多媒体流库</li><li>libVLC ：libVLC (VLC SDK)媒体框架</li><li>QtAv：基于Qt和FFmpeg的多媒体播放框架，能够帮助你轻而易举地编写出一个播放器</li><li>SDL ：简单直控媒体层</li><li>SFML ：快速，简单的多媒体库</li></ul><p>网络</p><ul><li>ACE：C++面向对象网络变成工具包</li><li>Boost.Asio：用于网络和底层I/O编程的跨平台的C++库</li><li>Casablanca：C++ REST SDK</li><li>cpp-netlib：高级网络编程的开源库集合</li><li>Dyad.c：C语言的异步网络</li><li>libcurl :多协议文件传输库</li><li>Mongoose：非常轻量级的网络服务器</li><li>Muduo ：用于Linux多线程服务器的C++非阻塞网络库</li><li>net_skeleton ：C/C++的TCP 客户端/服务器库</li><li>nope.c ：基于C语言的超轻型软件平台，用于可扩展的服务器端和网络应用。 对于C编程人员，可以考虑node.js</li><li>Onion :C语言HTTP服务器库，其设计为轻量级，易使用。</li><li>POCO：用于构建网络和基于互联网应用程序的C++类库，可以运行在桌面，服务器，移动和嵌入式系统。</li><li>RakNet：为游戏开发人员提供的跨平台的开源C++网络引擎。</li><li>Tuf o ：用于Qt之上的C++构建的异步Web框架。</li><li>WebSocket++ ：基于C++/Boost Aiso的websocket 客户端/服务器库</li><li>ZeroMQ ：高速，模块化的异步通信库</li></ul><p>物理学</p><p>动力学仿真引擎</p><ul><li>Box2D：2D的游戏物理引擎。</li><li>Bullet ：3D的游戏物理引擎。</li><li>Chipmunk ：快速，轻量级的2D游戏物理库</li><li>LiquidFun：2D的游戏物理引擎</li><li>ODE ：开放动力学引擎-开源，高性能库，模拟刚体动力学。</li><li>ofxBox2d：Box2D开源框架包装器。</li><li>Simbody ：高性能C++多体动力学/物理库，模拟关节生物力学和机械系统，像车辆，机器人和人体骨骼。</li></ul><p>机器人学</p><ul><li>MOOS-IvP ：一组开源C++模块，提供机器人平台的自主权，尤其是自主的海洋车辆。</li><li>MRPT：移动机器人编程工具包</li><li>PCL ：点云库是一个独立的，大规模的开放项目，用于2D/3D图像和点云处理。</li><li>Robotics Library (RL)： 一个独立的C++库，包括机器人动力学，运动规划和控制。</li><li>RobWork：一组C++库的集合，用于机器人系统的仿真和控制。</li><li>ROS ：机器人操作系统，提供了一些库和工具帮助软件开发人员创建机器人应用程序。</li></ul><p>科学计算</p><ul><li>FFTW :用一维或者多维计算DFT的C语言库。</li><li>GSL：GNU科学库。</li></ul><p>脚本</p><ul><li>ChaiScript ：用于C++的易于使用的嵌入式脚本语言。</li><li>Lua ：用于配置文件和基本应用程序脚本的小型快速脚本引擎。</li><li>luacxx：用于创建Lua绑定的C++ 11 API</li><li>SWIG ：一个可以让你的C++代码链接到JavaScript，Perl，PHP，Python，Tcl和Ruby的包装器/接口生成器</li><li>V7：嵌入式的JavaScript 引擎。</li><li>V8 ：谷歌的快速JavaScript引擎，可以被嵌入到任何C++应用程序中。</li></ul><p>序列化</p><ul><li>Cap’n Proto ：快速数据交换格式和RPC系统。</li><li>cereal ：C++11 序列化库</li><li>FlatBuffers ：内存高效的序列化库</li><li>MessagePack ：C/C++的高效二进制序列化库，例如 JSON</li><li>protobuf ：协议缓冲，谷歌的数据交换格式。</li><li>protobuf-c ：C语言的协议缓冲实现</li><li>SimpleBinaryEncoding：用于低延迟应用程序的对二进制格式的应用程序信息的编码和解码。</li><li>Thrift ：高效的跨语言IPC/RPC，用于C++，Java，Python，PHP，C#和其它多种语言中，最初由Twitter开发。</li></ul><p>视频</p><ul><li>libvpx ：VP8/VP9编码解码SDK</li><li>FFmpeg ：一个完整的，跨平台的解决方案，用于记录，转换视频和音频流。</li><li>libde265 ：开放的h.265视频编解码器的实现。</li><li>OpenH264：开源H.364 编解码器。</li><li>Theora ：免费开源的视频压缩格式。</li></ul><p>虚拟机</p><ul><li>CarpVM：C中有趣的VM，让我们一起来看看这个。</li><li>MicroPython ：旨在实现单片机上Python3.x的实现</li><li>TinyVM：用纯粹的ANSI C编写的小型，快速，轻量级的虚拟机。</li></ul><p>Web应用框架</p><ul><li>Civetweb ：提供易于使用，强大的，C/C++嵌入式Web服务器，带有可选的CGI，SSL和Lua支持。</li><li>CppCMS ：免费高性能的Web开发框架（不是 CMS）.</li><li>Crow ：一个C++微型web框架（灵感来自于Python Flask）</li><li>Kore :使用C语言开发的用于web应用程序的超快速和灵活的web服务器/框架。</li><li>libOnion：轻量级的库，帮助你使用C编程语言创建web服务器。</li><li>QDjango：使用C++编写的，基于Qt库的web框架，试图效仿Django API，因此得此名。</li><li>Wt ：开发Web应用的C++库。</li></ul><p>XML</p><p>XML就是个垃圾，xml的解析很烦人，对于计算机它也是个灾难。这种糟糕的东西完全没有存在的理由了。-Linus Torvalds</p><ul><li>Expat ：用C语言编写的xml解析库</li><li>Libxml2 ：Gnome的xml C解析器和工具包</li><li>libxml++ ：C++的xml解析器</li><li>PugiXML ：用于C++的，支持XPath的轻量级，简单快速的XML解析器。</li><li>RapidXml ：试图创建最快速的XML解析器，同时保持易用性，可移植性和合理的W3C兼容性。</li><li>TinyXML ：简单小型的C++XML解析器，可以很容易地集成到其它项目中。</li><li>TinyXML2：简单快速的C++CML解析器，可以很容易集成到其它项目中。</li><li>TinyXML++：TinyXML的一个全新的接口，使用了C++的许多许多优势，模板，异常和更好的异常处理。</li><li>Xerces-C++ ：用可移植的C++的子集编写的XML验证解析器。</li></ul><p>多项混杂</p><p>一些有用的库或者工具，但是不适合上面的分类，或者还没有分类。</p><ul><li>C++ Format ：C++的小型，安全和快速格式化库</li><li>casacore ：从aips++ 派生的一系列C++核心库</li><li>cxx-prettyprint：用于C++容器的打印库</li><li>DynaPDF ：易于使用的PDF生成库</li><li>gcc-poison ：帮助开发人员禁止应用程序中的不安全的C/C++函数的简单的头文件。</li><li>googlemock：编写和使用C++模拟类的库</li><li>HTTP Parser ：C的http请求/响应解析器</li><li>libcpuid ：用于x86 CPU检测盒特征提取的小型C库</li><li>libevil ：许可证管理器</li><li>libusb：允许移动访问USB设备的通用USB库</li><li>PCRE：正则表达式C库，灵感来自于Perl中正则表达式的功能。</li><li>Remote Call Framework ：C++的进程间通信框架。</li><li>Scintilla ：开源的代码编辑控件</li><li>Serial Communication Library ：C++语言编写的跨平台，串口库。</li><li>SDS：C的简单动态字符串库</li><li>SLDR ：超轻的DNS解析器</li><li>SLRE： 超轻的正则表达式库</li><li>Stage ：移动机器人模拟器</li><li>VarTypes：C++/Qt4功能丰富，面向对象的管理变量的框架。</li><li>ZBar：‘条形码扫描器’库，可以扫描照片，图片和视频流中的条形码，并返回结果。</li><li>CppVerbalExpressions ：易于使用的C++正则表达式</li><li>QtVerbalExpressions：基于C++ VerbalExpressions 库的Qt库</li><li>PHP-CPP：使用C++来构建PHP扩展的库</li><li>Better String ：C的另一个字符串库，功能更丰富，但是没有缓冲溢出问题，还包含了一个C++包装器。</li></ul><p>软件</p><p>用于创建开发环境的软件<br>编译器</p><p>C/C++编译器列表</p><ul><li>Clang :由苹果公司开发的</li><li>GCC：GNU编译器集合</li><li>Intel C++ Compiler ：由英特尔公司开发</li><li>LLVM ：模块化和可重用编译器和工具链技术的集合</li><li>Microsoft Visual C++ ：MSVC，由微软公司开发</li><li>Open WatCom ：Watcom，C，C++和Fortran交叉编译器和工具</li><li>TCC ：轻量级的C语言编译器</li></ul><p>在线编译器</p><p>在线C/C++编译器列表</p><ul><li>codepad ：在线编译器/解释器，一个简单的协作工具</li><li>CodeTwist：一个简单的在线编译器/解释器，你可以粘贴的C,C++或者Java代码，在线执行并查看结果</li><li>coliru ：在线编译器/shell， 支持各种C++编译器</li><li>Compiler Explorer：交互式编译器，可以进行汇编输出</li><li>CompileOnline：Linux上在线编译和执行C++程序</li><li>Ideone ：一个在线编译器和调试工具，允许你在线编译源代码并执行，支持60多种编程语言。</li></ul><p>调试器</p><p>C/C++调试器列表</p><ul><li>Comparison of debuggers ：来自维基百科的调试器列表</li><li>GDB ：GNU调试器</li><li>Valgrind：内存调试，内存泄露检测，性能分析工具。</li></ul><p>集成开发环境（IDE）</p><p>C/C++集成开发环境列表</p><ul><li>AppCode ：构建与JetBrains’ IntelliJ IDEA 平台上的用于Objective-C，C,C++，Java和Java开发的集成开发环境</li><li>CLion：来自JetBrains的跨平台的C/C++的集成开发环境</li><li>Code::Blocks ：免费C，C++和Fortran的集成开发环境</li><li>CodeLite ：另一个跨平台的免费的C/C++集成开发环境</li><li>Dev-C++：可移植的C/C++/C++11集成开发环境</li><li>Eclipse CDT：基于Eclipse平台的功能齐全的C和C++集成开发环境</li><li>Geany ：轻量级的快速，跨平台的集成开发环境。</li><li>IBM VisualAge ：来自IBM的家庭计算机集成开发环境。</li><li>Irony-mode：由libclang驱动的用于Emacs的C/C++微模式</li><li>KDevelop：免费开源集成开发环境</li><li>Microsoft Visual Studio ：来自微软的集成开发环境</li><li>NetBeans ：主要用于Java开发的的集成开发环境，也支持其他语言，尤其是PHP，C/C++和HTML5。</li><li>Qt Creator：跨平台的C++，Javascript和QML集成开发环境，也是Qt SDK的一部分。</li><li>rtags：C/C++的客户端服务器索引，用于 跟基于clang的emacs的集成</li><li>Xcode ：由苹果公司开发</li><li>YouCompleteMe：一个用于Vim的根据你敲的代码快速模糊搜索并进行代码补全的引擎。</li></ul><p>构建系统</p><ul><li>Bear ：用于为clang工具生成编译数据库的工具</li><li>Biicode：基于文件的简单依赖管理器。</li><li>CMake ：跨平台的免费开源软件用于管理软件使用独立编译的方法进行构建的过程。</li><li>CPM：基于CMake和Git的C++包管理器</li><li>FASTBuild：高性能，开源的构建系统，支持高度可扩展性的编译，缓冲和网络分布。</li><li>Ninja ：专注于速度的小型构建系统</li><li>Scons ：使用Python scipt 配置的软件构建工具</li><li>tundra ：高性能的代码构建系统，甚至对于非常大型的软件项目，也能提供最好的增量构建次数。</li><li>tup：基于文件的构建系统，用于后台监控变化的文件。</li></ul><p>静态代码分析</p><p>提高质量，减少瑕疵的代码分析工具列表</p><ul><li>Cppcheck ：静态C/C++代码分析工具</li><li>include-what-you-use ：使用clang进行代码分析的工具，可以#include在C和C++文件中。</li><li>OCLint ：用于C，C++和Objective-C的静态源代码分析工具，用于提高质量，减少瑕疵。</li><li>Clang Static Analyzer：查找C，C++和Objective-C程序bug的源代码分析工具</li><li>List of tools for static code analysis ：来自维基百科的静态代码分析工具列表</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-标准库及框架自学收藏&quot;&gt;&lt;a href=&quot;#C-标准库及框架自学收藏&quot; class=&quot;headerlink&quot; title=&quot;C++标准库及框架自学收藏&quot;&gt;&lt;/a&gt;C++标准库及框架自学收藏&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;标准库&lt;/p&gt;
&lt;p&gt;C++标准库，包括了ST</summary>
      
    
    
    
    <category term="C++" scheme="https://lennon.work/categories/C/"/>
    
    
    <category term="c++" scheme="https://lennon.work/tags/c/"/>
    
    <category term="框架学习" scheme="https://lennon.work/tags/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="标准库" scheme="https://lennon.work/tags/%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>代码可读性规范</title>
    <link href="https://lennon.work/2021/04/13/code/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7/"/>
    <id>https://lennon.work/2021/04/13/code/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7/</id>
    <published>2021-04-13T10:03:58.331Z</published>
    <updated>2021-04-13T10:08:20.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、可读性的重要性"><a href="#一、可读性的重要性" class="headerlink" title="一、可读性的重要性"></a>一、可读性的重要性</h1><p>编程有很大一部分时间是在阅读代码，不仅要阅读自己的代码，而且要阅读别人的代码。因此，可读性良好的代码能够大大提高编程效率。</p><p>可读性良好的代码往往会让代码架构更好，因为程序员更愿意去修改这部分代码，而且也更容易修改。</p><p>只有在核心领域为了效率才可以放弃可读性，否则可读性是第一位。</p><h1 id="二、用名字表达代码含义"><a href="#二、用名字表达代码含义" class="headerlink" title="二、用名字表达代码含义"></a>二、用名字表达代码含义</h1><p>一些比较有表达力的单词：</p><table><thead><tr><th align="center">单词</th><th>可替代单词</th></tr></thead><tbody><tr><td align="center">send</td><td>deliver、dispatch、announce、distribute、route</td></tr><tr><td align="center">find</td><td>search、extract、locate、recover</td></tr><tr><td align="center">start</td><td>launch、create、begin、open</td></tr><tr><td align="center">make</td><td>create、set up、build、generate、compose、add、new</td></tr></tbody></table><p>使用 i、j、k 作为循环迭代器的名字过于简单，user_i、member_i 这种名字会更有表达力。因为循环层次越多，代码越难理解，有表达力的迭代器名字可读性会更高。</p><p>为名字添加形容词等信息能让名字更具有表达力，但是名字也会变长。名字长短的准则是：作用域越大，名字越长。因此只有在短作用域才能使用一些简单名字。</p><h1 id="三、名字不能带来歧义"><a href="#三、名字不能带来歧义" class="headerlink" title="三、名字不能带来歧义"></a>三、名字不能带来歧义</h1><p>起完名字要思考一下别人会对这个名字有何解读，会不会误解了原本想表达的含义。</p><p>布尔相关的命名加上 is、can、should、has 等前缀。</p><ul><li><p>用 min、max 表示数量范围；</p></li><li><p>用 first、last 表示访问空间的包含范围；</p></li><li><p>begin、end 表示访问空间的排除范围，即 end 不包含尾部。</p></li></ul><h1 id="四、良好的代码风格"><a href="#四、良好的代码风格" class="headerlink" title="四、良好的代码风格"></a>四、良好的代码风格</h1><p>适当的空行和缩进。</p><p>排列整齐的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;   <span class="comment">// 注释</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">11</span>;  <span class="comment">// 注释</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">111</span>; <span class="comment">// 注释</span></span><br></pre></td></tr></table></figure><p>语句顺序不能随意，比如与 html 表单相关联的变量的赋值应该和表单在 html 中的顺序一致。</p><h1 id="五、为何编写注释"><a href="#五、为何编写注释" class="headerlink" title="五、为何编写注释"></a>五、为何编写注释</h1><p>阅读代码首先会注意到注释，如果注释没太大作用，那么就会浪费代码阅读的时间。那些能直接看出含义的代码不需要写注释，特别是不需要为每个方法都加上注释，比如那些简单的 getter 和 setter 方法，为这些方法写注释反而让代码可读性更差。</p><p>不能因为有注释就随便起个名字，而是争取起个好名字而不写注释。</p><p>可以用注释来记录采用当前解决办法的思考过程，从而让读者更容易理解代码。</p><p>注释用来提醒一些特殊情况。</p><p>用 TODO 等做标记：</p><table><thead><tr><th>标记</th><th>用法</th></tr></thead><tbody><tr><td>TODO</td><td>待做</td></tr><tr><td>FIXME</td><td>待修复</td></tr><tr><td>HACK</td><td>粗糙的解决方案</td></tr><tr><td>XXX</td><td>危险！这里有重要的问题</td></tr></tbody></table><h1 id="六、如何编写注释"><a href="#六、如何编写注释" class="headerlink" title="六、如何编写注释"></a>六、如何编写注释</h1><p>尽量简洁明了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The first String is student&#x27;s name</span></span><br><span class="line"><span class="comment">// The Second Integer is student&#x27;s score</span></span><br><span class="line">Map&lt;String, Integer&gt; scoreMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student&#x27;s name -&gt; Student&#x27;s score</span></span><br><span class="line">Map&lt;String, Integer&gt; scoreMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>添加测试用例来说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Example: add(1, 2), return 3</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用专业名词来缩短概念上的解释，比如用设计模式名来说明代码。</p><h1 id="七、提高控制流的可读性"><a href="#七、提高控制流的可读性" class="headerlink" title="七、提高控制流的可读性"></a>七、提高控制流的可读性</h1><p>条件表达式中，左侧是变量，右侧是常数。比如下面第一个语句正确：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">10</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="number">10</span> &gt; len)</span><br></pre></td></tr></table></figure><p>只有在逻辑简单的情况下使用 ? : 三目运算符来使代码更紧凑，否则应该拆分成 if / else；</p><p>do / while 的条件放在后面，不够简单明了，并且会有一些迷惑的地方，最好使用 while 来代替。</p><p>如果只有一个 goto 目标，那么 goto 尚且还能接受，但是过于复杂的 goto 会让代码可读性特别差，应该避免使用 goto。</p><p>在嵌套的循环中，用一些 return 语句往往能减少嵌套的层数。</p><h1 id="八、拆分长表达式"><a href="#八、拆分长表达式" class="headerlink" title="八、拆分长表达式"></a>八、拆分长表达式</h1><p>长表达式的可读性很差，可以引入一些解释变量从而拆分表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> line.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>].strip() == <span class="string">&quot;root&quot;</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">username = line.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>].strip()</span><br><span class="line"><span class="keyword">if</span> username == <span class="string">&quot;root&quot;</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>使用摩根定理简化一些逻辑表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!a &amp;&amp; !b) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(a || b)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="九、变量与可读性"><a href="#九、变量与可读性" class="headerlink" title="九、变量与可读性"></a>九、变量与可读性</h1><p><strong>去除控制流变量</strong>  。在循环中通过使用 break 或者 return 可以减少控制流变量的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="comment">/* condition */</span> &amp;&amp; !done) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ( ... ) &#123;</span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="comment">/* condition */</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ( ... ) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>减小变量作用域</strong>  。作用域越小，越容易定位到变量所有使用的地方。</p><p>JavaScript 可以用闭包减小作用域。以下代码中 submit_form 是函数变量，submitted 变量控制函数不会被提交两次。第一个实现中 submitted 是全局变量，第二个实现把 submitted 放到匿名函数中，从而限制了起作用域范围。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">submitted = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> submit_form = <span class="function"><span class="keyword">function</span>(<span class="params">form_name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (submitted) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    submitted = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> submit_form = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> submitted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">form_name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(submitted) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        submitted = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());  <span class="comment">// () 使得外层匿名函数立即执行</span></span><br></pre></td></tr></table></figure><p>JavaScript 中没有用 var 声明的变量都是全局变量，而全局变量很容易造成迷惑，因此应当总是用 var 来声明变量。</p><p>变量定义的位置应当离它使用的位置最近。</p><p><strong>实例解析</strong>  </p><p>在一个网页中有以下文本输入字段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;text&quot;</span> <span class="attr">id</span> = <span class="string">&quot;input1&quot;</span> <span class="attr">value</span> = <span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;text&quot;</span> <span class="attr">id</span> = <span class="string">&quot;input2&quot;</span> <span class="attr">value</span> = <span class="string">&quot;b&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;text&quot;</span> <span class="attr">id</span> = <span class="string">&quot;input3&quot;</span> <span class="attr">value</span> = <span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;text&quot;</span> <span class="attr">id</span> = <span class="string">&quot;input4&quot;</span> <span class="attr">value</span> = <span class="string">&quot;d&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在要接受一个字符串并把它放到第一个空的 input 字段中，初始实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setFirstEmptyInput = <span class="function"><span class="keyword">function</span>(<span class="params">new_alue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span> + i);</span><br><span class="line">    <span class="keyword">while</span> (elem != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elem.value === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        elem = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (found) elem.value = new_value;</span><br><span class="line">    <span class="keyword">return</span> elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实现有以下问题：</p><ul><li>found 可以去除；</li><li>elem 作用域过大；</li><li>可以用 for 循环代替 while 循环；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setFirstEmptyInput = <span class="function"><span class="keyword">function</span>(<span class="params">new_value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span> + i);</span><br><span class="line">        <span class="keyword">if</span> (elem === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (elem.value === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">            elem.value = new_value;</span><br><span class="line">            <span class="keyword">return</span> elem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="十、抽取函数"><a href="#十、抽取函数" class="headerlink" title="十、抽取函数"></a>十、抽取函数</h1><p>工程学就是把大问题拆分成小问题再把这些问题的解决方案放回一起。</p><p>首先应该明确一个函数的高层次目标，然后对于不是直接为了这个目标工作的代码，抽取出来放到独立的函数中。</p><p>介绍性的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findClostElement</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clostIdx;</span><br><span class="line">    <span class="keyword">int</span> clostDist = Interger.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = ...;</span><br><span class="line">        <span class="keyword">int</span> y = ...;</span><br><span class="line">        <span class="keyword">int</span> z = ...;</span><br><span class="line">        <span class="keyword">int</span> value = x * y * z;</span><br><span class="line">        <span class="keyword">int</span> dist = Math.sqrt(Math.pow(value, <span class="number">2</span>), Math.pow(arr[i], <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">if</span> (dist &lt; clostDist) &#123;</span><br><span class="line">            clostIdx = i;</span><br><span class="line">            clostDist = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clostIdx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中循环部分主要计算距离，这部分不属于代码高层次目标，高层次目标是寻找最小距离的值，因此可以把这部分代替提取到独立的函数中。这样做也带来一个额外的好处有：可以单独进行测试、可以快速找到程序错误并修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findClostElement</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clostIdx;</span><br><span class="line">    <span class="keyword">int</span> clostDist = Interger.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> dist = computDist(arr, i);</span><br><span class="line">        <span class="keyword">if</span> (dist &lt; clostDist) &#123;</span><br><span class="line">            clostIdx = i;</span><br><span class="line">            clostDist = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clostIdx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并不是函数抽取的越多越好，如果抽取过多，在阅读代码的时候可能需要不断跳来跳去。只有在当前函数不需要去了解某一块代码细节而能够表达其内容时，把这块代码抽取成子函数才是好的。</p><p>函数抽取也用于减小代码的冗余。</p><h1 id="十一、一次只做一件事"><a href="#十一、一次只做一件事" class="headerlink" title="十一、一次只做一件事"></a>十一、一次只做一件事</h1><p>只做一件事的代码很容易让人知道其要做的事；</p><p>基本流程：列出代码所做的所有任务；把每个任务拆分到不同的函数，或者不同的段落。</p><h1 id="十二、用自然语言表述代码"><a href="#十二、用自然语言表述代码" class="headerlink" title="十二、用自然语言表述代码"></a>十二、用自然语言表述代码</h1><p>先用自然语言书写代码逻辑，也就是伪代码，然后再写代码，这样代码逻辑会更清晰。</p><h1 id="十三、减少代码量"><a href="#十三、减少代码量" class="headerlink" title="十三、减少代码量"></a>十三、减少代码量</h1><p>不要过度设计，编码过程会有很多变化，过度设计的内容到最后往往是无用的。</p><p>多用标准库实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、可读性的重要性&quot;&gt;&lt;a href=&quot;#一、可读性的重要性&quot; class=&quot;headerlink&quot; title=&quot;一、可读性的重要性&quot;&gt;&lt;/a&gt;一、可读性的重要性&lt;/h1&gt;&lt;p&gt;编程有很大一部分时间是在阅读代码，不仅要阅读自己的代码，而且要阅读别人的代码。因此，</summary>
      
    
    
    
    <category term="代码可读性规范" scheme="https://lennon.work/categories/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="code可读性" scheme="https://lennon.work/tags/code%E5%8F%AF%E8%AF%BB%E6%80%A7/"/>
    
    <category term="规范" scheme="https://lennon.work/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>IP反查域名（一）</title>
    <link href="https://lennon.work/2021/04/11/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/search_domain_by_ip/"/>
    <id>https://lennon.work/2021/04/11/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/search_domain_by_ip/</id>
    <published>2021-04-11T14:58:54.406Z</published>
    <updated>2021-01-04T13:13:13.687Z</updated>
    
    <content type="html"><![CDATA[<h3 id="域名系统简介"><a href="#域名系统简介" class="headerlink" title="域名系统简介"></a>域名系统简介</h3><h4 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h4><p>的英文名称是Domain Name System，缩写是DNS，他是互联网的一项服务，是一种将域名和IP地址相互关联的数据库。让用户方便、快捷使用互联网。</p><hr><h4 id="为啥要引入？"><a href="#为啥要引入？" class="headerlink" title="为啥要引入？"></a>为啥要引入？</h4><ul><li>现实生活中，由于ip数量巨大，记忆困难，输入也极不方便，直接使用ip地址直接访问某一个主机会特别麻烦</li><li>主机ip地址经常更换，更换后需要更新原ip地址库</li></ul><p>为解决以上不方便，特地引入域名这一概念，域名既是给ip地址起别名，用户只需要记录域名，让专门的服务去寻找ip地址</p><hr><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><p>将域名解析成IP地址的过程即为域名解析，这一工作由DNS服务器完成</p><p><img src="/img/search_domain_by_ip/dns_server.png" alt="dns_server"></p><p>​    </p><p><img src="/img/search_domain_by_ip/pingbaidu.png" alt="pingbaidu"></p><p>通过向dns服务器发送query请求即可查询到想要查询的域名的ip地址</p><hr><h3 id="IP反查域名"><a href="#IP反查域名" class="headerlink" title="IP反查域名"></a>IP反查域名</h3><p>顾名思义 在知道ip地址的情况下，需要查询ip上绑定的域名信息。</p><p><strong>同一个ip可以在不同时间绑定多个域名，但是同一时间只能绑定一个域名</strong></p><p>因此搜集到的域名是具有时效的</p><hr><h4 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h4><h5 id="特有网站查询："><a href="#特有网站查询：" class="headerlink" title="特有网站查询："></a>特有网站查询：</h5><p>ip历史解析记录，由<a href="https://ip138.com/">ip138.com</a>维护的历史ip解析记录查询</p><p><a href="https://site.ip138.com/">https://site.ip138.com/</a>（推荐）</p><p><img src="/img/search_domain_by_ip/search.png" alt="search"></p><p><img src="/img/search_domain_by_ip/search2.png" alt="search2"></p><p><a href="https://www.webscan.cc/">https://www.webscan.cc/</a></p><p><a href="https://dns.aizhan.com/">https://dns.aizhan.com/</a></p><hr><h5 id="证书搜集"><a href="#证书搜集" class="headerlink" title="证书搜集"></a>证书搜集</h5><p>如果服务器开启的Web服务端口有配备SSL证书，可以在证书中查看到域名信息。</p><p><img src="/img/search_domain_by_ip/cert.png" alt="cert"></p><!--如果站点使用自签证书，或者证书无效等是看不到域名信息的--><hr><h5 id="网站信息收集"><a href="#网站信息收集" class="headerlink" title="网站信息收集"></a>网站信息收集</h5><p>访问站点开放http、https服务，从站点返回信息（响应头、响应体）中可能能获取到域名信息</p><p>下一节将通过代码实现通过证书信息获取到域名信息，敬请期待</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;域名系统简介&quot;&gt;&lt;a href=&quot;#域名系统简介&quot; class=&quot;headerlink&quot; title=&quot;域名系统简介&quot;&gt;&lt;/a&gt;域名系统简介&lt;/h3&gt;&lt;h4 id=&quot;域名系统&quot;&gt;&lt;a href=&quot;#域名系统&quot; class=&quot;headerlink&quot; title=&quot;域</summary>
      
    
    
    
    <category term="网络安全" scheme="https://lennon.work/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="dns" scheme="https://lennon.work/tags/dns/"/>
    
  </entry>
  
  <entry>
    <title>Common Platform Enumeration(CPE)</title>
    <link href="https://lennon.work/2021/04/11/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/cpe/"/>
    <id>https://lennon.work/2021/04/11/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/cpe/</id>
    <published>2021-04-11T14:58:54.405Z</published>
    <updated>2021-01-24T12:47:40.318Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>CPE全称是Common Platform Enumeration，意思是通用平台枚举项。它是NMAP对识别出来的软件、操作系统和硬件的一种命名方式。</p></blockquote><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><blockquote><p>cpe:/<part>:<vendor>:<product>:<version>:<update>:<edition>:<language></p></blockquote><ol><li><p>part表示目标类<br>a：应用程序<br>h：硬件平台<br>o：操作系统</p></li><li><p>vendor表示向量类型；</p></li><li><p>product表示产品名称</p></li><li><p>version表示版本号；</p></li><li><p>update表示更新包；</p></li><li><p>edition表示版本；</p></li><li><p>language表示语言项。</p></li></ol><p><img src="/img/CPE/cpe.jpg" alt="cpe"></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>CPE:/o:microsoft:windows_xp:::x86:,CPE:/o:microsoft:windows_vista:::x86:</p><p>part : o 操作系统</p><p>vendor：microsoft</p><p>product ：windows_xp</p><p>version：</p><p>update：</p><p>edition：x86</p><p>language：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;CPE全称是Common Platform Enumeration，意思是通用平台枚举项。它是NMAP对识别出来的</summary>
      
    
    
    
    <category term="网络安全" scheme="https://lennon.work/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="基础知识" scheme="https://lennon.work/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Hello 2021!</title>
    <link href="https://lennon.work/2021/04/11/%E6%9D%82%E8%B0%88/Hello%202021!/"/>
    <id>https://lennon.work/2021/04/11/%E6%9D%82%E8%B0%88/Hello%202021!/</id>
    <published>2021-04-11T14:58:54.402Z</published>
    <updated>2021-01-02T14:46:10.420Z</updated>
    
    <content type="html"><![CDATA[<h4 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h4><p>很庆幸你能看到这篇博客</p><p>作为2020的幸存者，为逝者默哀</p><p><img src="/img/20210101/moai.jpg"></p><hr><h3 id="2020"><a href="#2020" class="headerlink" title="2020?"></a>2020?</h3><p>感觉超级快有木有</p><p>回顾疫情爆发时间已经是前年的九月份</p><p>已经过去了一年多</p><p>都说2020是多灾多难的一年</p><p>疫情 火灾 洪水 还有科比</p><p>都再我们身边发生</p><p>真是 太难了</p><p><img src="/img/20210101/tainanle.jpg" alt="tainanle"></p><hr><h4 id="1-3月份"><a href="#1-3月份" class="headerlink" title="1-3月份"></a>1-3月份</h4><p>疫情肆虐 武汉封城</p><p>今年不回家了</p><p>不给国家添乱</p><p> 一个人留在南京</p><p>也不算一个人</p><p>还有我的明明陪我</p><p>熬过了每天的新增</p><p>熬过了周围小区偶尔爆出的病例</p><p>熬过了每天的孤独</p><p>做饭成为了最大的乐趣</p><p>厨艺倒是有了些许的进步</p><p><img src="/img/20210101/woyaochuqu.gif" alt="woyaochuqu"></p><p><img src="/img/20210101/pingtu1.jpg" alt="pingtu1"></p><hr><h4 id="3-4月"><a href="#3-4月" class="headerlink" title="3-4月"></a>3-4月</h4><p>在家办公</p><p>事不多</p><p>得自己找事情做</p><p>打完卡继续睡？</p><p>睡醒起来迷迷糊糊回个消息</p><p>下午准点打卡下班</p><p>起锅造饭 </p><p>今天的晚餐我又有新点子啦</p><p> <img src="/img/20210101/woyaoshangban.jpg" alt="woyaoshangban"></p><hr><h4 id="5-6月"><a href="#5-6月" class="headerlink" title="5-6月"></a>5-6月</h4><p>洪水到哪里？</p><p> 四川重庆？ 湖南湖北？ 安徽江西？</p><p>总和同事讨论这些话题</p><p>乐此不疲</p><p>这段时间普遍自己带饭</p><p>红烧排骨 辣子鸡丁</p><p>不存在的</p><p>番茄炒鸡蛋是拿手</p><p>啥都吃 啥都能活</p><p><img src="/img/20210101/pingtu4.jpg" alt="pingtu4"></p><hr><h4 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h4><p>国庆终于有机会回家一趟</p><p>好友 亲朋 家人</p><p>辗转 重庆 成都 然后回家</p><p>everything is on control</p><p><img src="/img/20210101/pingtu2.jpg" alt="pingtu2"></p><hr><p><img src="/img/20210101/pingtu3.jpg" alt="pingtu3"></p><hr><p><img src="/img/20210101/pigntu5.jpg" alt="pigntu5"></p><hr><p>归程 大概受到某某人的印象</p><p>决定是时候脱单了</p><p>找一个愿意长期甚至一辈子的对象</p><p><strong>慕然回首</strong></p><p><strong>那人正在灯火阑珊处</strong></p><p><img src="/img/20210101/qianshou.jpg" alt="qianshou"></p><hr><h4 id="年末"><a href="#年末" class="headerlink" title="年末"></a>年末</h4><p>经过爱情洗礼了两个月</p><p>用一个“得偿所愿”形容</p><p>不禁感慨</p><p>我也值得甜甜的爱</p><p><img src="/img/20210101/kaixin.gif" alt="kaixin"><img src="/img/20210101/kaixin.gif" alt="kaixin"></p><hr><h3 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h3><p><em>辞2020，迎2021</em></p><p><em>新的开始 新的所遇</em></p><p><img src="/img/20210101/2020-2.png" alt="2020-2"></p><hr><p>又长了一岁</p><p>又多一分压力</p><p>钱包没见多</p><p>花呗只见涨</p><p><strong>财务自由</strong></p><p><strong>从还完花呗开始吧</strong></p><p>超前消费正毒害年轻的我</p><p>钱包守卫战正在打响</p><p><img src="/img/20210101/qianbao.jpg" alt="qianbao"><img src="/img/20210101/daji.jpg" alt="daji"></p><hr><p>我爱的人 </p><p>爱我的人 </p><p>都要健健康康 </p><p>幸福开心</p><hr><p>每天乐观开心 </p><p>积极向上 </p><p>早起（这个再说）</p><p><img src="/img/20210101/buxiangqichuang.jpg" alt="buxiangqichuang"></p><hr><p>八块腹肌不现实 </p><p>那就两块胸肌 </p><p>决定了[拳头]</p><p><img src="/img/20210101/fuji.jpg" alt="fuji"></p><hr><p>golang大神？</p><p>从渣渣开始</p><p><img src="/img/20210101/zhazha.jpg" alt="zhazha"></p><hr><p>涨 涨 涨 </p><p>你知道我想要什么</p><p><img src="/img/20210101/fanche.gif" alt="fanche"></p><hr><p>你居然翻到这里了</p><p>哈哈</p><p>祝 ： 元旦之际 节日安康</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;置顶&quot;&gt;&lt;a href=&quot;#置顶&quot; class=&quot;headerlink&quot; title=&quot;置顶&quot;&gt;&lt;/a&gt;置顶&lt;/h4&gt;&lt;p&gt;很庆幸你能看到这篇博客&lt;/p&gt;
&lt;p&gt;作为2020的幸存者，为逝者默哀&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/20210101/moa</summary>
      
    
    
    
    <category term="杂谈" scheme="https://lennon.work/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="2021" scheme="https://lennon.work/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>常用工具包汇总一</title>
    <link href="https://lennon.work/2021/04/11/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"/>
    <id>https://lennon.work/2021/04/11/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/</id>
    <published>2021-04-11T14:58:54.399Z</published>
    <updated>2021-01-25T11:59:20.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h1><hr><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>神器 置顶</p><p>下载链接 <a href="https://git-scm.com/">https://git-scm.com/</a></p><hr><h3 id="typora"><a href="#typora" class="headerlink" title="typora"></a>typora</h3><p>下载链接 <a href="https://www.typora.io/">https://www.typora.io/</a></p><hr><h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><h4 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h4><p>官方下载链接 <a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a></p><p>出于语言驱动原因，尽量使用低于最新版本一点的版本</p><p>jdk安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">usr_local_dir=/usr/local</span><br><span class="line">java_dir=/usr/local/java </span><br><span class="line">etc_profile=/etc/profile</span><br><span class="line">if [ ! -d $usr_local_dir ]; then</span><br><span class="line">  mkdir $usr_local_dir</span><br><span class="line">fi</span><br><span class="line">if [ ! -d $java_dir ]; then</span><br><span class="line">  mkdir $java_dir</span><br><span class="line">fi</span><br><span class="line">if [ ! -d $etc_profile ]; then</span><br><span class="line">  mkdir $etc_profile</span><br><span class="line">fi</span><br><span class="line">echo &quot;---------安装java环境---------&quot;</span><br><span class="line">tar -zxf  jdk-8u181-linux-x64.tar.gz -C $java_dir</span><br><span class="line">echo &quot;export JAVA_HOME=$java_dir/jdk1.8.0_181&quot; &gt;&gt; $etc_profile</span><br><span class="line">echo &quot;export PATH=\$PATH:\$JAVA_HOME/bin&quot; &gt;&gt; $etc_profile</span><br><span class="line">ln -s $java_dir/jdk1.8.0_181/bin/java /usr/bin/java</span><br><span class="line">echo &quot;---------java环境安装成功---------&quot;</span><br></pre></td></tr></table></figure><p>elasticsearch安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">elk_dir=/home/elk</span><br><span class="line">es_node_name=node-1</span><br><span class="line">es_jvm=12g</span><br><span class="line"></span><br><span class="line">opt_dir=/home/opt</span><br><span class="line">if [ ! -d &quot;$opt_dir&quot; ]; then</span><br><span class="line">  mkdir &quot;$opt_dir&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;--------安装elasticsearch-------&quot;</span><br><span class="line">if [ ! -d &quot;$elk_dir&quot; ]; then</span><br><span class="line">  mkdir &quot;$elk_dir&quot;</span><br><span class="line">fi</span><br><span class="line">es_mkdir_cmd=&quot;mkdir $&#123;elk_dir&#125;&quot;</span><br><span class="line">es_config=&quot;$&#123;elk_dir&#125;/elasticsearch-7.9.1/config/&quot;</span><br><span class="line">tar -zxf elasticsearch-7.9.1-linux-x86_64.tar.gz -C $elk_dir</span><br><span class="line">adduser=&quot;adduser elkusr&quot;</span><br><span class="line">chownes=&quot;chown elkusr:elkusr -R $&#123;elk_dir&#125;/elasticsearch-7.9.1&quot;</span><br><span class="line"><span class="meta">$</span><span class="bash">adduser</span></span><br><span class="line"><span class="meta">$</span><span class="bash">chownes</span></span><br><span class="line"></span><br><span class="line">sed -i &quot;s/-Xms2g/-Xms$&#123;es_jvm&#125;/g&quot; $&#123;es_config&#125;jvm.options</span><br><span class="line">sed -i &quot;s/-Xmx2g/-Xmx$&#123;es_jvm&#125;/g&quot; $&#123;es_config&#125;jvm.options</span><br><span class="line">echo &quot;vm.max_map_count=655360&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br><span class="line"><span class="meta">#</span><span class="bash">该设置需要重启方可生效，解决max file descriptors [4096] <span class="keyword">for</span> elasticsearch process is too low的问题</span></span><br><span class="line">echo &quot;* soft nofile 65536&quot; &gt;&gt; /etc/security/limits.conf</span><br><span class="line">echo &quot;* hard nofile 131072&quot; &gt;&gt; /etc/security/limits.conf</span><br><span class="line">echo &quot;* soft nproc 2048&quot; &gt;&gt; /etc/security/limits.conf</span><br><span class="line">echo &quot;* hard nproc 4096&quot; &gt;&gt; /etc/security/limits.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">解决max number of threads [1024] <span class="keyword">for</span> user [es] is too low, increase to at least [2048]</span></span><br><span class="line">thread_conf=$(find /etc/security/limits.d/*.conf | head -n 1)</span><br><span class="line">echo &quot; * soft nproc 4096&quot; &gt;&gt; $&#123;thread_conf&#125;</span><br><span class="line">echo &quot; * hard nproc 4096&quot; &gt;&gt; $&#123;thread_conf&#125;</span><br><span class="line">echo &quot;--------elasticsearch安装成功-------&quot;</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><hr><h4 id="Cerebro"><a href="#Cerebro" class="headerlink" title="Cerebro"></a>Cerebro</h4><p>cerebro需要JDK1.8或者更新的版本予以支持，最简单的方式莫过于使用Docker镜像方式启动服务了。</p><p>安装</p><p>docker镜像安装</p><blockquote><p>docker pull lmenezes/cerebro:0.8.4</p><p>docker run –name cerebro -d -p 9100:9000  lmenezes/cerebro:0.8.4</p></blockquote><p>docker-compose安装</p><p>docker-compose.yml</p><blockquote><p>version: ‘2’<br>services:</p><p>  #cerebro service<br>  cerebro:<br>    image: lmenezes/cerebro:0.8.4<br>    ports:<br>      - “9100:9000”<br>        restart: “no”</p></blockquote><blockquote><p>docker-compose build cerebro<br>docker-compose up cerebro</p></blockquote><hr><h4 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h4><p>解压后进入 bin目录下</p><p>官方下载链接<a href="https://www.elastic.co/cn/downloads/kibana">https://www.elastic.co/cn/downloads/kibana</a></p><p>版本尽量与elasticsearch版本保持一致</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sudo -u elkusr ./kibana &gt;/dev/null &amp;  #不能在root用户下，安全原因</span><br></pre></td></tr></table></figure><hr><h3 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a>mongodb</h3><h4 id="mongodb-1"><a href="#mongodb-1" class="headerlink" title="mongodb"></a>mongodb</h4><p>官方下载链接 <a href="https://www.mongodb.com/try/download/community">https://www.mongodb.com/try/download/community</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mongodb_dir=/home/mongo</span><br><span class="line"></span><br><span class="line">if [ ! -d &quot;$mongodb_dir&quot; ]; then</span><br><span class="line">  mkdir &quot;$mongodb_dir&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash">进入压缩包目录，执行解压操作：</span></span><br><span class="line">tar -zxf mongodb-linux-x86_64-4.0.4.tgz -C /home/opt/mongodb</span><br><span class="line">cd /home/opt/mongodb/ </span><br><span class="line">mv -f mongodb-linux-x86_64-4.0.4/* .   #移动内容至mongodb</span><br><span class="line">mkdir db        #数据库存放目录</span><br><span class="line">mkdir logs       #日志存放目录</span><br><span class="line">touch logs/mongodb.log   #日志文件</span><br></pre></td></tr></table></figure><hr><h4 id="NoSQLBooster-for-MongoDB"><a href="#NoSQLBooster-for-MongoDB" class="headerlink" title="NoSQLBooster for MongoDB"></a>NoSQLBooster for MongoDB</h4><p><a href="https://nosqlbooster.com/downloads">https://nosqlbooster.com/downloads</a></p><hr><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><h4 id="redis-1"><a href="#redis-1" class="headerlink" title="redis"></a>redis</h4><p>下载链接 <a href="https://github.com/redis/redis">https://github.com/redis/redis</a> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">opt_dir=/home/</span><br><span class="line">if [ ! -d &quot;$opt_dir&quot; ]; then</span><br><span class="line">  mkdir &quot;$opt_dir&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">redis_dir=/home/redis</span><br><span class="line">if [ ! -d &quot;$redis_dir&quot; ]; then</span><br><span class="line">  mkdir &quot;$redis_dir&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">tar -zxf redis-5.0.2.tar.gz -C /home/opt/redis</span><br><span class="line">cd /home/opt/redis/redis-5.0.2</span><br><span class="line">rm -rf /softs/redis-5.0.2.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash">执行编译操作：</span></span><br><span class="line">yum -y install gcc gcc-c++ kernel-devel</span><br><span class="line">make</span><br><span class="line"><span class="meta">#</span><span class="bash">安装：</span></span><br><span class="line">make PREFIX=/home/opt/redis install</span><br><span class="line">cp redis.conf /home/opt/redis/bin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">修改配置：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">vi /home/opt/redis/bin/redis.conf</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis以守护进程的方式运行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> no表示不以守护进程的方式运行(会占用一个终端)</span>  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">daemonize yes</span></span><br><span class="line">sed -i  &#x27;s/daemonize no/daemonize yes/g&#x27; /home/opt/redis/bin/redis.conf</span><br><span class="line">cd /home/opt/redis/bin</span><br><span class="line">cp redis-cli /usr/bin/</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd /</span><br><span class="line">exit 0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="Redis-DeskTop-Manager"><a href="#Redis-DeskTop-Manager" class="headerlink" title="Redis DeskTop Manager"></a>Redis DeskTop Manager</h4><p>下载链接 <a href="https://github.com/qishibo/AnotherRedisDesktopManager/releases">https://github.com/qishibo/AnotherRedisDesktopManager/releases</a></p><hr><h3 id="wareshark"><a href="#wareshark" class="headerlink" title="wareshark"></a>wareshark</h3><p>下载链接  <a href="https://www.wireshark.org/">https://www.wireshark.org/</a></p><hr><h3 id="postman"><a href="#postman" class="headerlink" title="postman"></a>postman</h3><p>下载链接 <a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a></p><hr><h3 id="xshell"><a href="#xshell" class="headerlink" title="xshell"></a>xshell</h3><p>下载链接 <a href="https://xshell.en.softonic.com/">https://xshell.en.softonic.com/</a></p><hr><h3 id="JetBrains大礼包"><a href="#JetBrains大礼包" class="headerlink" title="JetBrains大礼包"></a>JetBrains大礼包</h3><p>goland <a href="https://www.jetbrains.com/go/">https://www.jetbrains.com/go/</a></p><p>pycharm <a href="https://www.jetbrains.com/pycharm/">https://www.jetbrains.com/pycharm/</a></p><p>PhpStorm  <a href="https://www.jetbrains.com/phpstorm/">https://www.jetbrains.com/phpstorm/</a></p><hr><h3 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h3><p>下载链接 <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p><hr><h3 id="navicat"><a href="#navicat" class="headerlink" title="navicat"></a>navicat</h3><p>下载链接 <a href="http://www.navicat.com.cn/store/navicat-premium">http://www.navicat.com.cn/store/navicat-premium</a></p><hr><h3 id="sublime"><a href="#sublime" class="headerlink" title="sublime"></a>sublime</h3><p><a href="http://www.sublimetext.com/3">http://www.sublimetext.com/3</a></p><hr><h3 id="visio-amp-processon-com"><a href="#visio-amp-processon-com" class="headerlink" title="visio &amp; processon.com"></a>visio &amp; processon.com</h3><p>绘图软件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用工具&quot;&gt;&lt;a href=&quot;#常用工具&quot; class=&quot;headerlink&quot; title=&quot;常用工具&quot;&gt;&lt;/a&gt;常用工具&lt;/h1&gt;&lt;hr&gt;
&lt;h3 id=&quot;git&quot;&gt;&lt;a href=&quot;#git&quot; class=&quot;headerlink&quot; title=&quot;git&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="工具包" scheme="https://lennon.work/categories/%E5%B7%A5%E5%85%B7%E5%8C%85/"/>
    
    
    <category term="自用" scheme="https://lennon.work/tags/%E8%87%AA%E7%94%A8/"/>
    
    <category term="redis" scheme="https://lennon.work/tags/redis/"/>
    
    <category term="elasticsearch" scheme="https://lennon.work/tags/elasticsearch/"/>
    
    <category term="shell" scheme="https://lennon.work/tags/shell/"/>
    
    <category term="mongo" scheme="https://lennon.work/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>常用工具包汇总二</title>
    <link href="https://lennon.work/2021/04/11/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8C%85%E6%B1%87%E6%80%BB/"/>
    <id>https://lennon.work/2021/04/11/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8C%85%E6%B1%87%E6%80%BB/</id>
    <published>2021-04-11T14:58:54.398Z</published>
    <updated>2021-01-25T12:01:35.301Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-开发工具"><a href="#一-开发工具" class="headerlink" title="一. 开发工具"></a><strong>一. 开发工具</strong></h2><p><strong>1)sql2go</strong><br>用于将 sql 语句转换为 golang 的 struct. 使用 ddl 语句即可。<br>例如对于创建表的语句: show create table xxx. 将输出的语句，直接粘贴进去就行。<br><a href="http://stming.cn/tool/sql2go.html">http://stming.cn/tool/sql2go.html</a></p><p><strong>2)toml2go</strong><br>用于将编码后的 toml 文本转换问 golang 的 struct.<br><a href="https://xuri.me/toml-to-go/">https://xuri.me/toml-to-go/</a></p><p><strong>3)curl2go</strong><br>用来将 curl 命令转化为具体的 golang 代码.<br><a href="https://mholt.github.io/curl-to-go/">https://mholt.github.io/curl-to-go/</a></p><p><strong>4)json2go</strong><br>用于将 json 文本转换为 struct.<br><a href="https://mholt.github.io/json-to-go/">https://mholt.github.io/json-to-go/</a></p><p><strong>5)mysql 转 ES 工具</strong><br><a href="http://www.ischoolbar.com/EsParser/">http://www.ischoolbar.com/EsParser/</a></p><p><strong>6)golang</strong><br>模拟模板的工具，在支持泛型之前，可以考虑使用。<br><a href="https://github.com/cheekybits/genny">https://github.com/cheekybits/genny</a></p><p><strong>7)查看某一个库的依赖情况，类似于 go list 功能</strong><br><a href="https://github.com/KyleBanks/depth">https://github.com/KyleBanks/depth</a></p><p><strong>8)一个好用的文件压缩和解压工具，集成了 zip，tar 等多种功能，主要还有跨平台。</strong><br><a href="https://github.com/mholt/archiver">https://github.com/mholt/archiver</a></p><p><strong>9)go 内置命令</strong><br>go list 可以查看某一个包的依赖关系.<br>go vet 可以检查代码不符合 golang 规范的地方。</p><p><strong>10)热编译工具</strong><br><a href="https://github.com/silenceper/gowatch">https://github.com/silenceper/gowatch</a></p><p><strong>11)revive</strong><br>golang 代码质量检测工具<br><a href="https://github.com/mgechev/revive">https://github.com/mgechev/revive</a></p><p><strong>12)Go Callvis</strong><br>golang 的代码调用链图工具<br><a href="https://github.com/TrueFurby/go-callvis">https://github.com/TrueFurby/go-callvis</a></p><p><strong>13)Realize</strong><br>开发流程改进工具<br><a href="https://github.com/oxequa/realize">https://github.com/oxequa/realize</a></p><p><strong>14)Gotests</strong><br>自动生成测试用例工具<br><a href="https://github.com/cweill/gotests">https://github.com/cweill/gotests</a></p><h2 id="二-调试工具"><a href="#二-调试工具" class="headerlink" title="二.调试工具"></a><strong>二.调试工具</strong></h2><p><strong>1)perf</strong><br>代理工具，支持内存，cpu，堆栈查看，并支持火焰图.<br>perf 工具和 go-torch 工具，快捷定位程序问题.<br><a href="https://github.com/uber-archive/go-torch">https://github.com/uber-archive/go-torch</a><br><a href="https://github.com/google/gops">https://github.com/google/gops</a></p><p><strong>2)dlv 远程调试</strong><br>基于 goland+dlv 可以实现远程调式的能力.<br><a href="https://github.com/go-delve/delve">https://github.com/go-delve/delve</a><br>提供了对 golang 原生的支持，相比 gdb 调试，简单太多。</p><p><strong>3)网络代理工具</strong><br>goproxy 代理，支持多种协议，支持 ssh 穿透和 kcp 协议.<br><a href="https://github.com/snail007/goproxy">https://github.com/snail007/goproxy</a></p><p><strong>4)抓包工具</strong><br>go-sniffer 工具，可扩展的抓包工具，可以开发自定义协议的工具包. 现在只支持了 http，mysql，redis，mongodb.<br>基于这个工具，我们开发了 qapp 协议的抓包。<br><a href="https://github.com/40t/go-sniffer">https://github.com/40t/go-sniffer</a></p><p><strong>5)反向代理工具，快捷开放内网端口供外部使用。</strong><br>ngrok 可以让内网服务外部调用<br><a href="https://ngrok.com/">https://ngrok.com/</a><br><a href="https://github.com/inconshreveable/ngrok">https://github.com/inconshreveable/ngrok</a></p><p><strong>6)配置化生成证书</strong><br>从根证书，到业务侧证书一键生成.<br><a href="https://github.com/cloudflare/cfssl">https://github.com/cloudflare/cfssl</a></p><p><strong>7)免费的证书获取工具</strong><br>基于 acme 协议，从 letsencrypt 生成免费的证书，有效期 1 年，可自动续期。<br><a href="https://github.com/Neilpang/acme.sh">https://github.com/Neilpang/acme.sh</a></p><p>8)开发环境管理工具，单机搭建可移植工具的利器。支持多种虚拟机后端。<br><strong>vagrant</strong>常被拿来同 docker 相比，值得拥有。<br><a href="https://github.com/hashicorp/vagrant">https://github.com/hashicorp/vagrant</a></p><p><strong>9)轻量级容器调度工具</strong><br>nomad 可以非常方便的管理容器和传统应用，相比 k8s 来说，简单不要太多.<br><a href="https://github.com/hashicorp/nomad">https://github.com/hashicorp/nomad</a></p><p><strong>10)敏感信息和密钥管理工具</strong><br><a href="https://github.com/hashicorp/vault">https://github.com/hashicorp/vault</a></p><p><strong>11)高度可配置化的 http 转发工具，基于 etcd 配置。</strong><br><a href="https://github.com/gojek/weaver">https://github.com/gojek/weaver</a></p><p><strong>12)进程监控工具 supervisor</strong><br><a href="https://www.jianshu.com/p/39b476e808d8">https://www.jianshu.com/p/39b476e808d8</a></p><p><strong>13)基于</strong>procFile<strong>进程管理工具. 相比 supervisor 更加简单。</strong><br><a href="https://github.com/ddollar/foreman">https://github.com/ddollar/foreman</a></p><p><strong>14)基于 http，https，websocket 的</strong>调试代理工具<strong>，配置功能丰富。在线教育的 nohost web 调试工具，基于此开发.</strong><br><a href="https://github.com/avwo/whistle">https://github.com/avwo/whistle</a></p><p><strong>15)分布式调度工具</strong><br><a href="https://github.com/shunfei/cronsun/blob/master/README_ZH.md">https://github.com/shunfei/cronsun/blob/master/README_ZH.md</a><br><a href="https://github.com/ouqiang/gocron">https://github.com/ouqiang/gocron</a></p><p><strong>16)自动化运维平台 Gaia</strong><br><a href="https://github.com/gaia-pipeline/gaia">https://github.com/gaia-pipeline/gaia</a></p><h2 id="三-常用网站"><a href="#三-常用网站" class="headerlink" title="三. 常用网站"></a><strong>三. 常用网站</strong></h2><p>go 百科全书: <a href="https://awesome-go.com/">https://awesome-go.com/</a><br>json 解析: <a href="https://www.json.cn/">https://www.json.cn/</a><br>出口 IP: <a href="https://ipinfo.io/">https://ipinfo.io/</a><br>redis 命令: <a href="http://doc.redisfans.com/">http://doc.redisfans.com/</a><br>ES 命令首页: <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html">https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html</a><br>UrlEncode: <a href="http://tool.chinaz.com/Tools/urlencode.aspx">http://tool.chinaz.com/Tools/urlencode.aspx</a><br>Base64: <a href="https://tool.oschina.net/encrypt%3Ftype%3D3">https://tool.oschina.net/encrypt?type=3</a><br>Guid: <a href="https://www.guidgen.com/">https://www.guidgen.com/</a><br>常用工具: <a href="http://www.ofmonkey.com/">http://www.ofmonkey.com/</a></p><h2 id="四-golang-常用库"><a href="#四-golang-常用库" class="headerlink" title="四. golang 常用库"></a><strong>四. golang 常用库</strong></h2><p><strong>日志</strong><br><a href="https://github.com/Sirupsen/logrus">https://github.com/Sirupsen/logrus</a><br><a href="https://github.com/uber-go/zap">https://github.com/uber-go/zap</a></p><p><strong>配置</strong><br>兼容 json，toml，yaml，hcl 等格式的日志库.<br><a href="https://github.com/spf13/viper">https://github.com/spf13/viper</a></p><p><strong>存储</strong><br>mysql <a href="https://github.com/go-xorm/xorm">https://github.com/go-xorm/xorm</a><br>es <a href="https://github.com/elastic/elasticsearch">https://github.com/elastic/elasticsearch</a><br>redis <a href="https://github.com/gomodule/redigo">https://github.com/gomodule/redigo</a><br>mongo <a href="https://github.com/mongodb/mongo-go-driver">https://github.com/mongodb/mongo-go-driver</a><br>kafka <a href="https://github.com/Shopify/sarama">https://github.com/Shopify/sarama</a></p><p><strong>数据结构</strong><br><a href="https://github.com/emirpasic/gods">https://github.com/emirpasic/gods</a></p><p><strong>命令行</strong><br><a href="https://github.com/spf13/cobra">https://github.com/spf13/cobra</a></p><p><strong>框架</strong><br><a href="https://github.com/grpc/grpc-go">https://github.com/grpc/grpc-go</a><br><a href="https://github.com/gin-gonic/gin">https://github.com/gin-gonic/gin</a></p><p><strong>并发</strong><br><a href="https://github.com/Jeffail/tunny">https://github.com/Jeffail/tunny</a><br><a href="https://github.com/benmanns/goworker">https://github.com/benmanns/goworker</a><br>现在我们框架在用的，虽然 star 不多，但是确实好用，当然还可以更好用.<br><a href="https://github.com/rafaeldias/async">https://github.com/rafaeldias/async</a></p><p><strong>工具</strong><br>定义了实用的判定类，以及针对结构体的校验逻辑，避免业务侧写复杂的代码.<br><a href="https://github.com/asaskevich/govalidator">https://github.com/asaskevich/govalidator</a><br><a href="https://github.com/bytedance/go-tagexpr">https://github.com/bytedance/go-tagexpr</a></p><p>protobuf 文件动态解析的接口，可以实现反射相关的能力。<br><a href="https://github.com/jhump/protoreflect">https://github.com/jhump/protoreflect</a></p><p><strong>表达式引擎工具</strong><br><a href="https://github.com/Knetic/govaluate">https://github.com/Knetic/govaluate</a><br><a href="https://github.com/google/cel-go">https://github.com/google/cel-go</a></p><p><strong>字符串处理</strong><br><a href="https://github.com/huandu/xstrings">https://github.com/huandu/xstrings</a></p><p><strong>ratelimit 工具</strong><br><a href="https://github.com/uber-go/ratelimit">https://github.com/uber-go/ratelimit</a><br><a href="https://blog.csdn.net/chenchongg/article/details/85342086">https://blog.csdn.net/chenchongg/article/details/85342086</a><br><a href="https://github.com/juju/ratelimit">https://github.com/juju/ratelimit</a></p><p><strong>golang 熔断的库</strong><br>熔断除了考虑频率限制，还要考虑 qps，出错率等其他东西.<br><a href="https://github.com/afex/hystrix-go">https://github.com/afex/hystrix-go</a><br><a href="https://github.com/sony/gobreaker">https://github.com/sony/gobreaker</a></p><p><strong>表格</strong><br><a href="https://github.com/chenjiandongx/go-echarts">https://github.com/chenjiandongx/go-echarts</a></p><p><strong>tail 工具库</strong><br><a href="https://github.com/hpcloud/taglshi">https://github.com/hpcloud/taglshi</a></p><h2 id="五-网络工具"><a href="#五-网络工具" class="headerlink" title="五. 网络工具"></a><strong>五. 网络工具</strong></h2><p><img src="/img/tools/nettools.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-开发工具&quot;&gt;&lt;a href=&quot;#一-开发工具&quot; class=&quot;headerlink&quot; title=&quot;一. 开发工具&quot;&gt;&lt;/a&gt;&lt;strong&gt;一. 开发工具&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1)sql2go&lt;/strong&gt;&lt;br&gt;用于将 sq</summary>
      
    
    
    
    <category term="工具包" scheme="https://lennon.work/categories/%E5%B7%A5%E5%85%B7%E5%8C%85/"/>
    
    
    <category term="golang" scheme="https://lennon.work/tags/golang/"/>
    
    <category term="工具包" scheme="https://lennon.work/tags/%E5%B7%A5%E5%85%B7%E5%8C%85/"/>
    
    <category term="调试工具" scheme="https://lennon.work/tags/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="学习比较" scheme="https://lennon.work/tags/%E5%AD%A6%E4%B9%A0%E6%AF%94%E8%BE%83/"/>
    
  </entry>
  
  <entry>
    <title>43. 字符串相乘</title>
    <link href="https://lennon.work/2021/04/11/leetcode/leetcode43/"/>
    <id>https://lennon.work/2021/04/11/leetcode/leetcode43/</id>
    <published>2021-04-11T14:58:54.395Z</published>
    <updated>2021-01-23T08:48:08.847Z</updated>
    
    <content type="html"><![CDATA[<h3 id="leetcode题库-43-字符串相乘"><a href="#leetcode题库-43-字符串相乘" class="headerlink" title="leetcode题库 43. 字符串相乘"></a>leetcode题库 43. 字符串相乘</h3><hr><h4 id="原题信息"><a href="#原题信息" class="headerlink" title="原题信息"></a>原题信息</h4><hr><h5 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接:"></a>原题链接:</h5><blockquote><p><a href="https://leetcode-cn.com/problems/multiply-strings/">https://leetcode-cn.com/problems/multiply-strings/</a></p></blockquote><hr><h5 id="难度等级"><a href="#难度等级" class="headerlink" title="难度等级"></a>难度等级</h5><blockquote><p>中等</p></blockquote><hr><h5 id="原题描述"><a href="#原题描述" class="headerlink" title="原题描述"></a>原题描述</h5><blockquote><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p></blockquote><p><img src="/img/lennon43/example.png" alt="example1"></p><hr><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><hr><h5 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h5><blockquote></blockquote><hr><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(num1 <span class="keyword">string</span>, num2 <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> num1 == <span class="string">&quot;0&quot;</span> || num2 == <span class="string">&quot;0&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result [<span class="number">110</span> + <span class="number">110</span>]<span class="keyword">int</span></span><br><span class="line">length := (<span class="built_in">len</span>(num1) - <span class="number">1</span>) + (<span class="built_in">len</span>(num2) - <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i1 := <span class="built_in">len</span>(num1) - <span class="number">1</span>; i1 &gt;= <span class="number">0</span>; i1-- &#123;</span><br><span class="line"><span class="keyword">for</span> i2 := <span class="built_in">len</span>(num2) - <span class="number">1</span>; i2 &gt;= <span class="number">0</span>; i2-- &#123;</span><br><span class="line">numx := (<span class="keyword">int</span>(num1[i1]) - <span class="number">48</span>) * (<span class="keyword">int</span>(num2[i2]) - <span class="number">48</span>)</span><br><span class="line"><span class="keyword">if</span> numx &gt;= <span class="number">10</span> &#123;</span><br><span class="line">result[i1+i2+<span class="number">1</span>] += numx % <span class="number">10</span></span><br><span class="line">result[i1+i2] += numx / <span class="number">10</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result[i1+i2+<span class="number">1</span>] += numx</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i3 := i1 + i2 + <span class="number">1</span>; i3 &gt;= <span class="number">0</span>; i3-- &#123;</span><br><span class="line">temp := result[i3]</span><br><span class="line"><span class="keyword">if</span> temp &gt;= <span class="number">10</span> &#123;</span><br><span class="line">result[i3] = temp % <span class="number">10</span></span><br><span class="line">result[i3<span class="number">-1</span>] += temp / <span class="number">10</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">str := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i3 := <span class="number">0</span>; i3 &lt;= length; i3++ &#123;</span><br><span class="line">str += <span class="keyword">string</span>(result[i3] + <span class="number">48</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> str[<span class="number">0</span>] == <span class="number">48</span> &#123;</span><br><span class="line">str = str[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h5><p><a href="https://github.com/lennon-liu/leetcode/tree/main/lennon43">https://github.com/lennon-liu/leetcode/tree/main/lennon43</a></p><hr><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p><img src="/img/lennon43/lennon43.png" alt="lennon2"></p><hr><h4 id="优化与总结"><a href="#优化与总结" class="headerlink" title="优化与总结"></a>优化与总结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><hr><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers">https://leetcode-cn.com/problems/add-two-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;leetcode题库-43-字符串相乘&quot;&gt;&lt;a href=&quot;#leetcode题库-43-字符串相乘&quot; class=&quot;headerlink&quot; title=&quot;leetcode题库 43. 字符串相乘&quot;&gt;&lt;/a&gt;leetcode题库 43. 字符串相乘&lt;/h3&gt;&lt;hr</summary>
      
    
    
    
    <category term="leetcode" scheme="https://lennon.work/categories/leetcode/"/>
    
    
    <category term="中等难度" scheme="https://lennon.work/tags/%E4%B8%AD%E7%AD%89%E9%9A%BE%E5%BA%A6/"/>
    
    <category term="golang实现" scheme="https://lennon.work/tags/golang%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="数组" scheme="https://lennon.work/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode题库 66. 加一</title>
    <link href="https://lennon.work/2021/04/11/leetcode/leetcode66/"/>
    <id>https://lennon.work/2021/04/11/leetcode/leetcode66/</id>
    <published>2021-04-11T14:58:54.394Z</published>
    <updated>2021-01-23T08:48:16.729Z</updated>
    
    <content type="html"><![CDATA[<h3 id="leetcode题库-66-加一"><a href="#leetcode题库-66-加一" class="headerlink" title="leetcode题库 66. 加一"></a>leetcode题库 66. 加一</h3><hr><h4 id="原题信息"><a href="#原题信息" class="headerlink" title="原题信息"></a>原题信息</h4><hr><h5 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接:"></a>原题链接:</h5><blockquote><p><a href="https://leetcode-cn.com/problems/search-insert-position/">https://leetcode-cn.com/problems/search-insert-position/</a></p></blockquote><hr><h5 id="难度等级"><a href="#难度等级" class="headerlink" title="难度等级"></a>难度等级</h5><blockquote><p>中等</p></blockquote><hr><h5 id="原题描述"><a href="#原题描述" class="headerlink" title="原题描述"></a>原题描述</h5><blockquote><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p></blockquote><p><img src="/img/lennon66/example.png" alt="example1"></p><blockquote><p>提示：<br>1 &lt;= digits.length &lt;= 100<br>0 &lt;= digits[i] &lt;= 9</p></blockquote><hr><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><hr><h5 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h5><blockquote></blockquote><hr><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plusOne</span><span class="params">(digits []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">digits[<span class="built_in">len</span>(digits)<span class="number">-1</span>] = digits[<span class="built_in">len</span>(digits)<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">max := <span class="built_in">len</span>(digits) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> digits[max] == <span class="number">10</span> &#123;</span><br><span class="line"><span class="keyword">if</span> max == <span class="number">0</span> &#123;</span><br><span class="line">digits[max] = <span class="number">0</span></span><br><span class="line">digits = <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;, digits...)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">digits[max] = <span class="number">0</span></span><br><span class="line">digits[max<span class="number">-1</span>] = digits[max<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> max &lt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">max -= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> digits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h5><blockquote><p><a href="https://github.com/lennon-liu/leetcode/tree/main/lennon35">https://github.com/lennon-liu/leetcode/tree/main/lennon35</a></p></blockquote><hr><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p><img src="/img/lennon66/lennon66.png" alt="lennon2"></p><hr><h4 id="优化与总结"><a href="#优化与总结" class="headerlink" title="优化与总结"></a>优化与总结</h4><blockquote></blockquote><hr><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers">https://leetcode-cn.com/problems/add-two-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;leetcode题库-66-加一&quot;&gt;&lt;a href=&quot;#leetcode题库-66-加一&quot; class=&quot;headerlink&quot; title=&quot;leetcode题库 66. 加一&quot;&gt;&lt;/a&gt;leetcode题库 66. 加一&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;原题</summary>
      
    
    
    
    <category term="leetcode" scheme="https://lennon.work/categories/leetcode/"/>
    
    
    <category term="golang实现" scheme="https://lennon.work/tags/golang%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="简单难度" scheme="https://lennon.work/tags/%E7%AE%80%E5%8D%95%E9%9A%BE%E5%BA%A6/"/>
    
    <category term="数组" scheme="https://lennon.work/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode题库 35. 搜索插入位置</title>
    <link href="https://lennon.work/2021/04/11/leetcode/leetcode35/"/>
    <id>https://lennon.work/2021/04/11/leetcode/leetcode35/</id>
    <published>2021-04-11T14:58:54.392Z</published>
    <updated>2021-01-23T08:48:23.488Z</updated>
    
    <content type="html"><![CDATA[<h3 id="leetcode题库-35-搜索插入位置"><a href="#leetcode题库-35-搜索插入位置" class="headerlink" title="leetcode题库 35. 搜索插入位置"></a>leetcode题库 35. 搜索插入位置</h3><hr><h4 id="原题信息"><a href="#原题信息" class="headerlink" title="原题信息"></a>原题信息</h4><hr><h5 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接:"></a>原题链接:</h5><blockquote><p><a href="https://leetcode-cn.com/problems/search-insert-position/">https://leetcode-cn.com/problems/search-insert-position/</a></p></blockquote><hr><h5 id="难度等级"><a href="#难度等级" class="headerlink" title="难度等级"></a>难度等级</h5><blockquote><p>简单</p></blockquote><hr><h5 id="原题描述"><a href="#原题描述" class="headerlink" title="原题描述"></a>原题描述</h5><blockquote><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p></blockquote><p><img src="/img/lennon35/example.png" alt="example1"></p><hr><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><hr><h5 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h5><blockquote></blockquote><hr><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i, n <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i, n = <span class="keyword">range</span> nums &#123;</span><br><span class="line"><span class="keyword">if</span> target &lt;= n &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h5><blockquote><p><a href="https://github.com/lennon-liu/leetcode/tree/main/lennon35">https://github.com/lennon-liu/leetcode/tree/main/lennon35</a></p></blockquote><hr><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p><img src="/img/lennon35/lennon35.png" alt="lennon2"></p><hr><h4 id="优化与总结"><a href="#优化与总结" class="headerlink" title="优化与总结"></a>优化与总结</h4><blockquote></blockquote><hr><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers">https://leetcode-cn.com/problems/add-two-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;leetcode题库-35-搜索插入位置&quot;&gt;&lt;a href=&quot;#leetcode题库-35-搜索插入位置&quot; class=&quot;headerlink&quot; title=&quot;leetcode题库 35. 搜索插入位置&quot;&gt;&lt;/a&gt;leetcode题库 35. 搜索插入位置&lt;/h3</summary>
      
    
    
    
    <category term="leetcode" scheme="https://lennon.work/categories/leetcode/"/>
    
    
    <category term="golang实现" scheme="https://lennon.work/tags/golang%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="简单难度" scheme="https://lennon.work/tags/%E7%AE%80%E5%8D%95%E9%9A%BE%E5%BA%A6/"/>
    
    <category term="数组" scheme="https://lennon.work/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>28. 实现 strStr()</title>
    <link href="https://lennon.work/2021/04/11/leetcode/leetcode28/"/>
    <id>https://lennon.work/2021/04/11/leetcode/leetcode28/</id>
    <published>2021-04-11T14:58:54.391Z</published>
    <updated>2021-01-23T08:48:32.600Z</updated>
    
    <content type="html"><![CDATA[<h3 id="leetcode题库-28-实现-strStr"><a href="#leetcode题库-28-实现-strStr" class="headerlink" title="leetcode题库 28. 实现 strStr()"></a>leetcode题库 28. 实现 strStr()</h3><hr><h4 id="原题信息"><a href="#原题信息" class="headerlink" title="原题信息"></a>原题信息</h4><hr><h5 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接:"></a>原题链接:</h5><blockquote><p><a href="https://leetcode-cn.com/problems/implement-strstr/">https://leetcode-cn.com/problems/implement-strstr/</a></p></blockquote><hr><h5 id="难度等级"><a href="#难度等级" class="headerlink" title="难度等级"></a>难度等级</h5><blockquote><p>简单</p></blockquote><hr><h5 id="原题描述"><a href="#原题描述" class="headerlink" title="原题描述"></a>原题描述</h5><blockquote><p>实现 strStr() 函数。<br>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p></blockquote><blockquote><p>示例 1:<br>输入: haystack = “hello”, needle = “ll”<br>输出: 2</p></blockquote><blockquote><p>######示例 2:<br>输入: haystack = “aaaaa”, needle = “bba”<br>输出: -1</p></blockquote><blockquote><p>说明:<br>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。<br>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p></blockquote><hr><h4 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h4><blockquote><p>字符串整行匹配</p></blockquote><hr><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><hr><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack <span class="keyword">string</span>, needle <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">i:=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="keyword">if</span> i&gt; <span class="built_in">len</span>(haystack) || <span class="built_in">len</span>(haystack[i:])&lt; <span class="built_in">len</span>(needle)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> haystack[i:i+<span class="built_in">len</span>(needle)]==needle &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">i+=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h5><p><a href="https://github.com/lennon-liu/leetcode/tree/main/lennon28">https://github.com/lennon-liu/leetcode/tree/main/lennon28</a></p><hr><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p><img src="/img/lennon28/lennon28.png" alt="lennon28"></p><hr><h4 id="优化与总结"><a href="#优化与总结" class="headerlink" title="优化与总结"></a>优化与总结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><hr><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers">https://leetcode-cn.com/problems/add-two-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;leetcode题库-28-实现-strStr&quot;&gt;&lt;a href=&quot;#leetcode题库-28-实现-strStr&quot; class=&quot;headerlink&quot; title=&quot;leetcode题库 28. 实现 strStr()&quot;&gt;&lt;/a&gt;leetcode题库 28.</summary>
      
    
    
    
    <category term="leetcode" scheme="https://lennon.work/categories/leetcode/"/>
    
    
    <category term="golang实现" scheme="https://lennon.work/tags/golang%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="简单难度" scheme="https://lennon.work/tags/%E7%AE%80%E5%8D%95%E9%9A%BE%E5%BA%A6/"/>
    
    <category term="字符串" scheme="https://lennon.work/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>16. 最接近的三数之和</title>
    <link href="https://lennon.work/2021/04/11/leetcode/leetcode16/"/>
    <id>https://lennon.work/2021/04/11/leetcode/leetcode16/</id>
    <published>2021-04-11T14:58:54.390Z</published>
    <updated>2021-01-24T11:41:28.470Z</updated>
    
    <content type="html"><![CDATA[<h3 id="leetcode题库-16-最接近的三数之和"><a href="#leetcode题库-16-最接近的三数之和" class="headerlink" title="leetcode题库 16. 最接近的三数之和"></a>leetcode题库 16. 最接近的三数之和</h3><hr><h4 id="原题信息"><a href="#原题信息" class="headerlink" title="原题信息"></a>原题信息</h4><hr><h5 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接:"></a>原题链接:</h5><blockquote><p><a href="https://leetcode-cn.com/problems/3sum-closest/">https://leetcode-cn.com/problems/3sum-closest/</a></p></blockquote><hr><h5 id="难度等级"><a href="#难度等级" class="headerlink" title="难度等级"></a>难度等级</h5><blockquote><p>中等</p></blockquote><hr><h5 id="原题描述"><a href="#原题描述" class="headerlink" title="原题描述"></a>原题描述</h5><blockquote><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。<br>返回这三个数的和。假定每组输入只存在唯一答案。</p></blockquote><blockquote><p>示例 1：<br>输入：nums = [-1,2,1,-4], target = 1<br> 输出：2<br> 解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</p></blockquote><blockquote><p>提示：<br>3 &lt;= nums.length &lt;= 10^3<br>-10^3 &lt;= nums[i] &lt;= 10^3<br>-10^4 &lt;= target &lt;= 10^4</p></blockquote><h4 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h4><blockquote><p>暴力遍历前两个数，在寻找第三个数，直接第三个数常规遍历会超时，因此得加入限制条件才可以。<br>最好先对数组排序,好处是可以在合适的位置跳出循环，减少没有必要的遍历。<br>对排序好的数组，最好使用二分法查找</p></blockquote><hr><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><hr><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twodivde</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line"><span class="comment">//fmt.Println(nums)</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">2</span>&#123;</span><br><span class="line"><span class="keyword">if</span> math.Abs(<span class="keyword">float64</span>(nums[<span class="number">0</span>]-target))-math.Abs(<span class="keyword">float64</span>(nums[<span class="number">1</span>]-target))&gt;<span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">return</span> nums[<span class="number">1</span>]</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">length:= <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"><span class="keyword">if</span> length%<span class="number">2</span>==<span class="number">0</span>&#123;</span><br><span class="line">length=length/<span class="number">2</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">length=(length<span class="number">-1</span>)/<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> target == nums[length]&#123;</span><br><span class="line"><span class="keyword">return</span> target</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> target &gt; nums[length]&#123;</span><br><span class="line"><span class="keyword">return</span> twodivde(nums[length:],target)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> twodivde(nums[:length+<span class="number">1</span>],target)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSumClosest</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">result:=<span class="number">0</span></span><br><span class="line">lastx:=<span class="keyword">float64</span>(<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">ttt:=<span class="number">0</span></span><br><span class="line">sort.Ints(nums)</span><br><span class="line"><span class="keyword">for</span> i1 := <span class="number">0</span>;i1&lt;=<span class="built_in">len</span>(nums)<span class="number">-3</span>;i1++&#123;</span><br><span class="line">lastnum3:=<span class="number">9999</span></span><br><span class="line"><span class="keyword">for</span> i2:=i1+<span class="number">1</span>;i2&lt;=<span class="built_in">len</span>(nums)<span class="number">-2</span>;i2++&#123;</span><br><span class="line">num3:=(target-nums[i1])-nums[i2]</span><br><span class="line"><span class="keyword">if</span> num3&gt;nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>]&#123;</span><br><span class="line">ttt= nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>]+nums[i2]+nums[i1]</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> num3&lt;nums[i2+<span class="number">1</span>]&#123;</span><br><span class="line">ttt= nums[i2+<span class="number">1</span>]+nums[i2]+nums[i1]</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">ttt=twodivde(nums,num3)+nums[i2]+nums[i1]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ttt-target==<span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">return</span> ttt</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> math.Abs(<span class="keyword">float64</span>(ttt-target))-math.Abs(lastx)&lt;<span class="number">0</span>&#123;</span><br><span class="line">lastx=<span class="keyword">float64</span>(ttt-target)</span><br><span class="line">result=ttt</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ttt-target&gt;<span class="number">0</span> &amp;&amp; ttt-lastnum3&gt;<span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">lastnum3=ttt</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a>代码链接</h5><blockquote><p><a href="https://github.com/lennon-liu/leetcode/tree/main/lennon16">https://github.com/lennon-liu/leetcode/tree/main/lennon16</a></p></blockquote><hr><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p><img src="/img/lennon16/lennon16.png" alt="lennon2"></p><hr><h4 id="优化与总结"><a href="#优化与总结" class="headerlink" title="优化与总结"></a>优化与总结</h4><blockquote></blockquote><hr><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers">https://leetcode-cn.com/problems/add-two-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;leetcode题库-16-最接近的三数之和&quot;&gt;&lt;a href=&quot;#leetcode题库-16-最接近的三数之和&quot; class=&quot;headerlink&quot; title=&quot;leetcode题库 16. 最接近的三数之和&quot;&gt;&lt;/a&gt;leetcode题库 16. 最接近的</summary>
      
    
    
    
    <category term="leetcode" scheme="https://lennon.work/categories/leetcode/"/>
    
    
    <category term="中等难度" scheme="https://lennon.work/tags/%E4%B8%AD%E7%AD%89%E9%9A%BE%E5%BA%A6/"/>
    
    <category term="golang实现" scheme="https://lennon.work/tags/golang%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="字符串" scheme="https://lennon.work/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
</feed>
